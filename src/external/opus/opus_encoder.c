#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include "opus_config.h"
#include "opus.h"


// Opus Defines ---------------------------------------------------------------

#define CELT_SET_END_BAND_REQUEST    10012

#define MAX_FINE_BITS 8
#define FINE_OFFSET 21

typedef int8_t opus_int8;
typedef uint8_t opus_uint8;
typedef int16_t opus_int16;
typedef uint16_t opus_uint16;
typedef int32_t opus_int32;
typedef uint32_t opus_uint32;
typedef int64_t opus_int64;
typedef uint64_t opus_uint64;

typedef struct { float r; float i; } fft_cpx;
typedef struct { float r; float i; } twiddle_cpx;

typedef struct
{
   unsigned char *buf;
   opus_uint32 storage, end_offs, end_window;
   int nend_bits, nbits_total;
   opus_uint32 offs, rng, val, ext;
   int rem, error;
} ec_ctx;


// Math Functions -------------------------------------------------------------

#define PI 3.141592653f
#define FRAC_MUL16(a,b) ((16384 + ((opus_int32)(opus_int16)(a) * (opus_int16)(b))) >> 15)

#if INT_MAX >= 2147483647
#define EC_CLZ0    ((int)sizeof(unsigned) * CHAR_BIT)
#define EC_CLZ(_x) (__builtin_clz(_x))
#elif LONG_MAX >= 2147483647L
#define EC_CLZ0    ((int)sizeof(unsigned long) * CHAR_BIT)
#define EC_CLZ(_x) (__builtin_clzl(_x))
#endif
#define EC_ILOG(_x) (EC_CLZ0 - EC_CLZ(_x))

#define celt_sqrt(x)          (sqrtf(x))
#define celt_rsqrt(x)         (1.f/celt_sqrt(x))
#define celt_rsqrt_norm(x)    (celt_rsqrt(x))
#define celt_cos_norm(x)      (cosf((.5f*PI)*(x)))
#define celt_rcp(x)           (1.f/(x))
#define celt_div(a,b)         ((a)/(b))
#define frac_div32(a,b)       ((float)(a)/(b))

static inline float celt_log2(float x)
{
   union { float f; opus_uint32 i; } in = { .f = x };
   const int integer = (in.i >> 23) - 127;
   in.i -= integer << 23;
   float frac = in.f - 1.5f;
   frac = -0.41445418f + frac*(0.95909232f + frac*(-0.33951290f + frac*0.16541097f));
   return 1 + integer + frac;
}

static inline float celt_inner_prod(const float *x, const float *y, int N)
{
   float xy = 0;
   for (int i = 0; i < N; ++i)
      xy += (float)x[i] * (float)y[i];
   return xy;
}

static inline opus_uint32 celt_udiv(opus_uint32 n, opus_uint32 d)
{   
   // Result of 2^32/(2*i+1), except for i=0
   static const opus_uint32 SMALL_DIV_TABLE[129] = {
      0xFFFFFFFF, 0x55555555, 0x33333333, 0x24924924, 0x1C71C71C, 0x1745D174, 0x13B13B13, 0x11111111, 0x0F0F0F0F, 0x0D79435E, 0x0C30C30C, 0x0B21642C, 0x0A3D70A3, 0x097B425E, 0x08D3DCB0, 0x08421084,
      0x07C1F07C, 0x07507507, 0x06EB3E45, 0x06906906, 0x063E7063, 0x05F417D0, 0x05B05B05, 0x0572620A, 0x05397829, 0x05050505, 0x04D4873E, 0x04A7904A, 0x047DC11F, 0x0456C797, 0x04325C53, 0x04104104,
      0x03F03F03, 0x03D22635, 0x03B5CC0E, 0x039B0AD1, 0x0381C0E0, 0x0369D036, 0x03531DEC, 0x033D91D2, 0x0329161F, 0x03159721, 0x03030303, 0x02F14990, 0x02E05C0B, 0x02D02D02, 0x02C0B02C, 0x02B1DA46,
      0x02A3A0FD, 0x0295FAD4, 0x0288DF0C, 0x027C4597, 0x02702702, 0x02647C69, 0x02593F69, 0x024E6A17, 0x0243F6F0, 0x0239E0D5, 0x02302302, 0x0226B902, 0x021D9EAD, 0x0214D021, 0x020C49BA, 0x02040810,
      0x01FC07F0, 0x01F44659, 0x01ECC07B, 0x01E573AC, 0x01DE5D6E, 0x01D77B65, 0x01D0CB58, 0x01CA4B30, 0x01C3F8F0, 0x01BDD2B8, 0x01B7D6C3, 0x01B20364, 0x01AC5701, 0x01A6D01A, 0x01A16D3F, 0x019C2D14,
      0x01970E4F, 0x01920FB4, 0x018D3018, 0x01886E5F, 0x0183C977, 0x017F405F, 0x017AD220, 0x01767DCE, 0x01724287, 0x016E1F76, 0x016A13CD, 0x01661EC6, 0x01623FA7, 0x015E75BB, 0x015AC056, 0x01571ED3,
      0x01539094, 0x01501501, 0x014CAB88, 0x0149539E, 0x01460CBC, 0x0142D662, 0x013FB013, 0x013C995A, 0x013991C2, 0x013698DF, 0x0133AE45, 0x0130D190, 0x012E025C, 0x012B404A, 0x01288B01, 0x0125E227,
      0x01234567, 0x0120B470, 0x011E2EF3, 0x011BB4A4, 0x01194538, 0x0116E068, 0x011485F0, 0x0112358E, 0x010FEF01, 0x010DB20A, 0x010B7E6E, 0x010953F3, 0x01073260, 0x0105197F, 0x0103091B, 0x01010101
   };

   if (d > 256)
      return n / d;
   else
   {
      const opus_uint32 t = EC_ILOG(d & -d);
      const opus_uint32 q = (opus_uint64)SMALL_DIV_TABLE[d >> t] * (n >> (t - 1)) >> 32;
      return q + (n - q * d >= d);
   }
}

static inline opus_int32 celt_sudiv(opus_int32 n, opus_int32 d)
{
   return (n < 0) ? -(opus_int32)celt_udiv(-n, d) : celt_udiv(n, d);
}


// Generic Encoder Functions --------------------------------------------------

#define EC_SYM_BITS     8
#define EC_CODE_BITS    32
#define EC_SYM_MAX      ((1U << EC_SYM_BITS) - 1)
#define EC_CODE_SHIFT   (EC_CODE_BITS - EC_SYM_BITS - 1)
#define EC_CODE_TOP     (((opus_uint32)1U) << (EC_CODE_BITS - 1))
#define EC_CODE_BOT     (EC_CODE_TOP >> EC_SYM_BITS)
#define EC_CODE_EXTRA   ((EC_CODE_BITS - 2) % EC_SYM_BITS + 1)
#define EC_WINDOW_SIZE  ((int)sizeof(opus_uint32) * CHAR_BIT)
#define EC_UINT_BITS    8
#define BITRES          3

static inline int ec_tell(ec_ctx *this) { return this->nbits_total - EC_ILOG(this->rng); }

static inline opus_uint32 ec_tell_frac(ec_ctx *_this)
{
  static const unsigned correction[8] = { 35733, 38967, 42495, 46340, 50535, 55109, 60097, 65535 };
  const int l = EC_ILOG(_this->rng);
  const opus_uint32 r = _this->rng >> (l - 16);
  unsigned b = (r >> 12) - 8;
  b += r > correction[b];
  return (_this->nbits_total << BITRES) - ((l << 3) + b);
}

static inline int ec_write_byte(ec_ctx *this, unsigned value)
{
   if (this->offs + this->end_offs >= this->storage)
      return -1;
   this->buf[this->offs++] = (unsigned char)value;
   return 0;
}

static inline int ec_write_byte_at_end(ec_ctx *this, unsigned value)
{
   if (this->offs + this->end_offs >= this->storage)
      return -1;
   this->buf[this->storage - ++this->end_offs] = (unsigned char)value;
   return 0;
}

static inline void ec_enc_carry_out(ec_ctx *this, int c)
{
   if(c != EC_SYM_MAX)
   {
      const int carry = c >> EC_SYM_BITS;
      if(this->rem >= 0)
         this->error |= ec_write_byte(this, this->rem + carry);
      if(this->ext > 0)
      {
         const unsigned sym = (EC_SYM_MAX + carry) & EC_SYM_MAX;
         do { this->error |= ec_write_byte(this,sym); } while(--this->ext > 0);
      }
      this->rem= c & EC_SYM_MAX;
   }
   else
      ++this->ext;
}

static inline void ec_enc_normalize(ec_ctx *this)
{
   while(this->rng <= EC_CODE_BOT)
   {
      ec_enc_carry_out(this, (int)(this->val >> EC_CODE_SHIFT));
      this->val = (this->val << EC_SYM_BITS) & (EC_CODE_TOP - 1);
      this->rng <<= EC_SYM_BITS;
      this->nbits_total += EC_SYM_BITS;
   }
}

static void ec_enc_init(ec_ctx *this, unsigned char *buf, opus_uint32 size)
{
   this->buf = buf;
   this->end_offs = this->end_window = 0;
   this->nend_bits = 0;
   this->nbits_total = EC_CODE_BITS+1;
   this->offs = 0;
   this->rng = EC_CODE_TOP;
   this->rem = -1;
   this->val = this->ext = 0;
   this->storage = size;
   this->error = 0;
}

static void ec_encode(ec_ctx *this, unsigned fl, unsigned fh, unsigned ft)
{
   const opus_uint32 r = celt_udiv(this->rng,ft);
   if (fl > 0)
   {
      this->val += this->rng - (r * (ft - fl));
      this->rng = r * (fh - fl);
   }
   else
      this->rng -= r * (ft - fh);
   ec_enc_normalize(this);
}

static inline void ec_encode_bin(ec_ctx *this, unsigned fl, unsigned fh)
{
   const opus_uint32 r = this->rng >> 15;
   if (fl > 0)
   {
      this->val += this->rng - (r * (32768 - fl));
      this->rng = r * (fh - fl);
   }
   else
      this->rng -= r * (32768 - fh);
   ec_enc_normalize(this);
}

static inline void ec_enc_bit_logp(ec_ctx *this, int val, unsigned logp)
{
   opus_uint32 r = this->rng, l = this->val, s = r >> logp;
   r -= s;
   if(val)
      this->val = l + r;
   this->rng = val ? s : r;
   ec_enc_normalize(this);
}

static inline void ec_enc_icdf(ec_ctx *this, int s, const unsigned char *icdf, unsigned ftb)
{
   const opus_uint32 r = this->rng >> ftb;
   if (s > 0)
   {
      this->val += this->rng - (r * icdf[s-1]);
      this->rng = r * (icdf[s-1] - icdf[s]);
   }
   else
      this->rng -= r * icdf[s];
   ec_enc_normalize(this);
}

static inline void ec_enc_bits(ec_ctx *this, opus_uint32 fl, unsigned bits)
{
   opus_uint32 window = this->end_window;
   int used = this->nend_bits;
   if ((used + bits) > EC_WINDOW_SIZE)
   {
      do
      {
         this->error |= ec_write_byte_at_end(this, (unsigned)window & EC_SYM_MAX);
         window >>= EC_SYM_BITS;
         used -= EC_SYM_BITS;
      }
      while (used >= EC_SYM_BITS);
   }
   window |= fl << used;
   used += bits;
   this->end_window = window;
   this->nend_bits = used;
   this->nbits_total += bits;
}

static inline void ec_enc_uint(ec_ctx *this, opus_uint32 fl, opus_uint32 ft)
{
   ft--;
   int ftb = EC_ILOG(ft);
   if (ftb > EC_UINT_BITS)
   {
      ftb -= EC_UINT_BITS;
      const unsigned tmpft = (ft >> ftb) + 1;
      const unsigned tmpfl = (unsigned)(fl >> ftb);
      ec_encode(this, tmpfl, tmpfl + 1, tmpft);
      ec_enc_bits(this, fl & (((opus_uint32)1 << ftb) - 1U), ftb);
   }
   else ec_encode(this, fl, fl + 1, ft + 1);
}

static inline void ec_enc_shrink(ec_ctx *this, opus_uint32 size)
{
   memmove(this->buf + size - this->end_offs, this->buf + this->storage - this->end_offs, this->end_offs);
   this->storage = size;
}

static inline void ec_enc_done(ec_ctx *this)
{
   int l = EC_CODE_BITS - EC_ILOG(this->rng);
   opus_uint32 msk = (EC_CODE_TOP - 1) >> l, end = (this->val + msk) & ~msk;
   if ((end | msk) >= (this->val + this->rng))
   {
      ++l;
      msk >>= 1;
      end = (this->val + msk) & ~msk;
   }
   while (l > 0)
   {
      ec_enc_carry_out(this, (int)(end >> EC_CODE_SHIFT));
      end = (end << EC_SYM_BITS) & (EC_CODE_TOP - 1);
      l -= EC_SYM_BITS;
   }
   if ((this->rem >= 0) || (this->ext > 0))
      ec_enc_carry_out(this, 0);
   opus_uint32 window = this->end_window;
   int used = this->nend_bits;
   while (used >= EC_SYM_BITS)
   {
      this->error |= ec_write_byte_at_end(this, (unsigned)window & EC_SYM_MAX);
      window >>= EC_SYM_BITS;
      used -= EC_SYM_BITS;
   }
   if (!this->error)
   {
      memset(this->buf + this->offs, 0, this->storage - this->offs - this->end_offs);
      if (used > 0)
      {
         if (this->end_offs >= this->storage)
            this->error=-1;
         else
         {
            l = -l;
            if (((this->offs + this->end_offs) >= this->storage) && l<used)
            {
               window &= (1 << l) - 1;
               this->error = -1;
            }
            this->buf[this->storage - this->end_offs - 1] |= (unsigned char)window;
         }
      }
   }
}


// CWRS Functions -------------------------------------------------------------

# define CELT_PVQ_U(_n,_k) (CELT_PVQ_U_ROW[MIN(_n,_k)][MAX(_n,_k)])
# define CELT_PVQ_V(_n,_k) (CELT_PVQ_U(_n,_k)+CELT_PVQ_U(_n,(_k)+1))

static const opus_uint32 CELT_PVQ_U_DATA[1272] = {
   /*N=0, K=0...176:*/
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   /*N=1, K=1...176:*/
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   /*N=2, K=2...176:*/
   3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41,
   43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79,
   81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113,
   115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143,
   145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173,
   175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203,
   205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233,
   235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 257, 259, 261, 263,
   265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293,
   295, 297, 299, 301, 303, 305, 307, 309, 311, 313, 315, 317, 319, 321, 323,
   325, 327, 329, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351,
   /*N=3, K=3...176:*/
   13, 25, 41, 61, 85, 113, 145, 181, 221, 265, 313, 365, 421, 481, 545, 613,
   685, 761, 841, 925, 1013, 1105, 1201, 1301, 1405, 1513, 1625, 1741, 1861,
   1985, 2113, 2245, 2381, 2521, 2665, 2813, 2965, 3121, 3281, 3445, 3613, 3785,
   3961, 4141, 4325, 4513, 4705, 4901, 5101, 5305, 5513, 5725, 5941, 6161, 6385,
   6613, 6845, 7081, 7321, 7565, 7813, 8065, 8321, 8581, 8845, 9113, 9385, 9661,
   9941, 10225, 10513, 10805, 11101, 11401, 11705, 12013, 12325, 12641, 12961,
   13285, 13613, 13945, 14281, 14621, 14965, 15313, 15665, 16021, 16381, 16745,
   17113, 17485, 17861, 18241, 18625, 19013, 19405, 19801, 20201, 20605, 21013,
   21425, 21841, 22261, 22685, 23113, 23545, 23981, 24421, 24865, 25313, 25765,
   26221, 26681, 27145, 27613, 28085, 28561, 29041, 29525, 30013, 30505, 31001,
   31501, 32005, 32513, 33025, 33541, 34061, 34585, 35113, 35645, 36181, 36721,
   37265, 37813, 38365, 38921, 39481, 40045, 40613, 41185, 41761, 42341, 42925,
   43513, 44105, 44701, 45301, 45905, 46513, 47125, 47741, 48361, 48985, 49613,
   50245, 50881, 51521, 52165, 52813, 53465, 54121, 54781, 55445, 56113, 56785,
   57461, 58141, 58825, 59513, 60205, 60901, 61601,
   /*N=4, K=4...176:*/
   63, 129, 231, 377, 575, 833, 1159, 1561, 2047, 2625, 3303, 4089, 4991, 6017,
   7175, 8473, 9919, 11521, 13287, 15225, 17343, 19649, 22151, 24857, 27775,
   30913, 34279, 37881, 41727, 45825, 50183, 54809, 59711, 64897, 70375, 76153,
   82239, 88641, 95367, 102425, 109823, 117569, 125671, 134137, 142975, 152193,
   161799, 171801, 182207, 193025, 204263, 215929, 228031, 240577, 253575,
   267033, 280959, 295361, 310247, 325625, 341503, 357889, 374791, 392217,
   410175, 428673, 447719, 467321, 487487, 508225, 529543, 551449, 573951,
   597057, 620775, 645113, 670079, 695681, 721927, 748825, 776383, 804609,
   833511, 863097, 893375, 924353, 956039, 988441, 1021567, 1055425, 1090023,
   1125369, 1161471, 1198337, 1235975, 1274393, 1313599, 1353601, 1394407,
   1436025, 1478463, 1521729, 1565831, 1610777, 1656575, 1703233, 1750759,
   1799161, 1848447, 1898625, 1949703, 2001689, 2054591, 2108417, 2163175,
   2218873, 2275519, 2333121, 2391687, 2451225, 2511743, 2573249, 2635751,
   2699257, 2763775, 2829313, 2895879, 2963481, 3032127, 3101825, 3172583,
   3244409, 3317311, 3391297, 3466375, 3542553, 3619839, 3698241, 3777767,
   3858425, 3940223, 4023169, 4107271, 4192537, 4278975, 4366593, 4455399,
   4545401, 4636607, 4729025, 4822663, 4917529, 5013631, 5110977, 5209575,
   5309433, 5410559, 5512961, 5616647, 5721625, 5827903, 5935489, 6044391,
   6154617, 6266175, 6379073, 6493319, 6608921, 6725887, 6844225, 6963943,
   7085049, 7207551,
   /*N=5, K=5...176:*/
   321, 681, 1289, 2241, 3649, 5641, 8361, 11969, 16641, 22569, 29961, 39041,
   50049, 63241, 78889, 97281, 118721, 143529, 172041, 204609, 241601, 283401,
   330409, 383041, 441729, 506921, 579081, 658689, 746241, 842249, 947241,
   1061761, 1186369, 1321641, 1468169, 1626561, 1797441, 1981449, 2179241,
   2391489, 2618881, 2862121, 3121929, 3399041, 3694209, 4008201, 4341801,
   4695809, 5071041, 5468329, 5888521, 6332481, 6801089, 7295241, 7815849,
   8363841, 8940161, 9545769, 10181641, 10848769, 11548161, 12280841, 13047849,
   13850241, 14689089, 15565481, 16480521, 17435329, 18431041, 19468809,
   20549801, 21675201, 22846209, 24064041, 25329929, 26645121, 28010881,
   29428489, 30899241, 32424449, 34005441, 35643561, 37340169, 39096641,
   40914369, 42794761, 44739241, 46749249, 48826241, 50971689, 53187081,
   55473921, 57833729, 60268041, 62778409, 65366401, 68033601, 70781609,
   73612041, 76526529, 79526721, 82614281, 85790889, 89058241, 92418049,
   95872041, 99421961, 103069569, 106816641, 110664969, 114616361, 118672641,
   122835649, 127107241, 131489289, 135983681, 140592321, 145317129, 150160041,
   155123009, 160208001, 165417001, 170752009, 176215041, 181808129, 187533321,
   193392681, 199388289, 205522241, 211796649, 218213641, 224775361, 231483969,
   238341641, 245350569, 252512961, 259831041, 267307049, 274943241, 282741889,
   290705281, 298835721, 307135529, 315607041, 324252609, 333074601, 342075401,
   351257409, 360623041, 370174729, 379914921, 389846081, 399970689, 410291241,
   420810249, 431530241, 442453761, 453583369, 464921641, 476471169, 488234561,
   500214441, 512413449, 524834241, 537479489, 550351881, 563454121, 576788929,
   590359041, 604167209, 618216201, 632508801,
   /*N=6, K=6...96:*/
   1683, 3653, 7183, 13073, 22363, 36365, 56695, 85305, 124515, 177045, 246047,
   335137, 448427, 590557, 766727, 982729, 1244979, 1560549, 1937199, 2383409,
   2908411, 3522221, 4235671, 5060441, 6009091, 7095093, 8332863, 9737793,
   11326283, 13115773, 15124775, 17372905, 19880915, 22670725, 25765455,
   29189457, 32968347, 37129037, 41699767, 46710137, 52191139, 58175189,
   64696159, 71789409, 79491819, 87841821, 96879431, 106646281, 117185651,
   128542501, 140763503, 153897073, 167993403, 183104493, 199284183, 216588185,
   235074115, 254801525, 275831935, 298228865, 322057867, 347386557, 374284647,
   402823977, 433078547, 465124549, 499040399, 534906769, 572806619, 612825229,
   655050231, 699571641, 746481891, 795875861, 847850911, 902506913, 959946283,
   1020274013, 1083597703, 1150027593, 1219676595, 1292660325, 1369097135,
   1449108145, 1532817275, 1620351277, 1711839767, 1807415257, 1907213187,
   2011371957, 2120032959,
   /*N=7, K=7...54*/
   8989, 19825, 40081, 75517, 134245, 227305, 369305, 579125, 880685, 1303777,
   1884961, 2668525, 3707509, 5064793, 6814249, 9041957, 11847485, 15345233,
   19665841, 24957661, 31388293, 39146185, 48442297, 59511829, 72616013,
   88043969, 106114625, 127178701, 151620757, 179861305, 212358985, 249612805,
   292164445, 340600625, 395555537, 457713341, 527810725, 606639529, 695049433,
   793950709, 904317037, 1027188385, 1163673953, 1314955181, 1482288821,
   1667010073, 1870535785, 2094367717,
   /*N=8, K=8...37*/
   48639, 108545, 224143, 433905, 795455, 1392065, 2340495, 3800305, 5984767,
   9173505, 13726991, 20103025, 28875327, 40754369, 56610575, 77500017,
   104692735, 139703809, 184327311, 240673265, 311207743, 398796225, 506750351,
   638878193, 799538175, 993696769, 1226990095, 1505789553, 1837271615,
   2229491905U,
   /*N=9, K=9...28:*/
   265729, 598417, 1256465, 2485825, 4673345, 8405905, 14546705, 24331777,
   39490049, 62390545, 96220561, 145198913, 214828609, 312193553, 446304145,
   628496897, 872893441, 1196924561, 1621925137, 2173806145U,
   /*N=10, K=10...24:*/
   1462563, 3317445, 7059735, 14218905, 27298155, 50250765, 89129247, 152951073,
   254831667, 413442773, 654862247, 1014889769, 1541911931, 2300409629U,
   3375210671U,
   /*N=11, K=11...19:*/
   8097453, 18474633, 39753273, 81270333, 158819253, 298199265, 540279585,
   948062325, 1616336765,
   /*N=12, K=12...18:*/
   45046719, 103274625, 224298231, 464387817, 921406335, 1759885185,
   3248227095U,
   /*N=13, K=13...16:*/
   251595969, 579168825, 1267854873, 2653649025U,
   /*N=14, K=14:*/
   1409933619
};

static const opus_uint32 *const CELT_PVQ_U_ROW[15] = {
   CELT_PVQ_U_DATA +    0, CELT_PVQ_U_DATA +  176, CELT_PVQ_U_DATA +  351,
   CELT_PVQ_U_DATA +  525, CELT_PVQ_U_DATA +  698, CELT_PVQ_U_DATA +  870,
   CELT_PVQ_U_DATA + 1041, CELT_PVQ_U_DATA + 1131, CELT_PVQ_U_DATA + 1178,
   CELT_PVQ_U_DATA + 1207, CELT_PVQ_U_DATA + 1226, CELT_PVQ_U_DATA + 1240,
   CELT_PVQ_U_DATA + 1248, CELT_PVQ_U_DATA + 1254, CELT_PVQ_U_DATA + 1257
};

static inline opus_uint32 icwrs(int n, const int *y)
{
   int j = n - 1, k = abs(y[j]);
   opus_uint32 i = y[j] < 0;
   do
   {
      --j;
      i += CELT_PVQ_U(n - j, k);
      k += abs(y[j]);
      if (y[j] < 0)
         i += CELT_PVQ_U(n - j, k + 1);
   } while (j > 0);
   return i;
}

static inline void encode_pulses(const int *y, int n, int k, ec_ctx *enc)
{
   ec_enc_uint(enc, icwrs(n, y), CELT_PVQ_V(n, k));
}


// CELT Encoder Implementation ------------------------------------------------

static const opus_int16 logN400[] = { 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 16, 16, 16, 21, 21, 24, 29, 34, 36, };
static const float window120[] = {
   6.7286966e-05f, 0.00060551348f, 0.0016815970f, 0.0032947962f, 0.0054439943f, 0.0081276923f, 0.011344001f, 0.015090633f, 0.019364886f, 0.024163635f,
   0.029483315f, 0.035319905f, 0.041668911f, 0.048525347f, 0.055883718f, 0.063737999f, 0.072081616f, 0.080907428f, 0.090207705f, 0.099974111f,
   0.11019769f, 0.12086883f, 0.13197729f, 0.14351214f, 0.15546177f, 0.16781389f, 0.18055550f, 0.19367290f, 0.20715171f, 0.22097682f,
   0.23513243f, 0.24960208f, 0.26436860f, 0.27941419f, 0.29472040f, 0.31026818f, 0.32603788f, 0.34200931f, 0.35816177f, 0.37447407f,
   0.39092462f, 0.40749142f, 0.42415215f, 0.44088423f, 0.45766484f, 0.47447104f, 0.49127978f, 0.50806798f, 0.52481261f, 0.54149077f,
   0.55807973f, 0.57455701f, 0.59090049f, 0.60708841f, 0.62309951f, 0.63891306f, 0.65450896f, 0.66986776f, 0.68497077f, 0.69980010f,
   0.71433873f, 0.72857055f, 0.74248043f, 0.75605424f, 0.76927895f, 0.78214257f, 0.79463430f, 0.80674445f, 0.81846456f, 0.82978733f,
   0.84070669f, 0.85121779f, 0.86131698f, 0.87100183f, 0.88027111f, 0.88912479f, 0.89756398f, 0.90559094f, 0.91320904f, 0.92042270f,
   0.92723738f, 0.93365955f, 0.93969656f, 0.94535671f, 0.95064907f, 0.95558353f, 0.96017067f, 0.96442171f, 0.96834849f, 0.97196334f,
   0.97527906f, 0.97830883f, 0.98106616f, 0.98356480f, 0.98581869f, 0.98784191f, 0.98964856f, 0.99125274f, 0.99266849f, 0.99390969f,
   0.99499004f, 0.99592297f, 0.99672162f, 0.99739874f, 0.99796667f, 0.99843728f, 0.99882195f, 0.99913147f, 0.99937606f, 0.99956527f,
   0.99970802f, 0.99981248f, 0.99988613f, 0.99993565f, 0.99996697f, 0.99998518f, 0.99999457f, 0.99999859f, 0.99999982f, 1.0000000f,
};
static const opus_int16 cache_index[] = {
   -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 41, 41, 41, 82, 82, 123, 164, 200, 222, 0, 0, 0, 0, 0, 0, 0, 0, 41, 41, 41, 41, 123, 123, 123, 164, 164, 240, 266, 283, 295, 41, 41, 41,
   41, 41, 41, 41, 41, 123, 123, 123, 123, 240, 240, 240, 266, 266, 305, 318, 328, 336, 123, 123, 123, 123, 123, 123, 123, 123, 240, 240, 240, 240,
   305, 305, 305, 318, 318, 343, 351, 358, 364, 240, 240, 240, 240, 240, 240, 240, 240, 305, 305, 305, 305, 343, 343, 343, 351, 351, 370, 376, 382, 387,
};
static const unsigned char cache_bits[] = {
   40, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 40, 15, 23, 28, 31, 34, 36, 38, 39, 41, 42, 43, 44, 45, 46, 47, 47, 49, 50,
   51, 52, 53, 54, 55, 55, 57, 58, 59, 60, 61, 62, 63, 63, 65, 66, 67, 68, 69, 70, 71, 71, 40, 20, 33, 41, 48, 53, 57, 61,
   64, 66, 69, 71, 73, 75, 76, 78, 80, 82, 85, 87, 89, 91, 92, 94, 96, 98, 101, 103, 105, 107, 108, 110, 112, 114, 117, 119, 121, 123,
   124, 126, 128, 40, 23, 39, 51, 60, 67, 73, 79, 83, 87, 91, 94, 97, 100, 102, 105, 107, 111, 115, 118, 121, 124, 126, 129, 131, 135, 139,
   142, 145, 148, 150, 153, 155, 159, 163, 166, 169, 172, 174, 177, 179, 35, 28, 49, 65, 78, 89, 99, 107, 114, 120, 126, 132, 136, 141, 145, 149,
   153, 159, 165, 171, 176, 180, 185, 189, 192, 199, 205, 211, 216, 220, 225, 229, 232, 239, 245, 251, 21, 33, 58, 79, 97, 112, 125, 137, 148, 157,
   166, 174, 182, 189, 195, 201, 207, 217, 227, 235, 243, 251, 17, 35, 63, 86, 106, 123, 139, 152, 165, 177, 187, 197, 206, 214, 222, 230, 237, 250,
   25, 31, 55, 75, 91, 105, 117, 128, 138, 146, 154, 161, 168, 174, 180, 185, 190, 200, 208, 215, 222, 229, 235, 240, 245, 255, 16, 36, 65, 89,
   110, 128, 144, 159, 173, 185, 196, 207, 217, 226, 234, 242, 250, 11, 41, 74, 103, 128, 151, 172, 191, 209, 225, 241, 255, 9, 43, 79, 110, 138,
   163, 186, 207, 227, 246, 12, 39, 71, 99, 123, 144, 164, 182, 198, 214, 228, 241, 253, 9, 44, 81, 113, 142, 168, 192, 214, 235, 255, 7, 49,
   90, 127, 160, 191, 220, 247, 6, 51, 95, 134, 170, 203, 234, 7, 47, 87, 123, 155, 184, 212, 237, 6, 52, 97, 137, 174, 208, 240, 5, 57,
   106, 151, 192, 231, 5, 59, 111, 158, 202, 243, 5, 55, 103, 147, 187, 224, 5, 60, 113, 161, 206, 248, 4, 65, 122, 175, 224, 4, 67, 127, 182, 234
};
static const unsigned char cache_caps[] = {
   224, 224, 224, 224, 224, 224, 224, 224, 160, 160, 160, 160, 185, 185, 185, 178, 178, 168, 134, 61, 37, 224, 224, 224, 224, 224, 224, 224, 224, 240,
   240, 240, 240, 207, 207, 207, 198, 198, 183, 144, 66, 40, 160, 160, 160, 160, 160, 160, 160, 160, 185, 185, 185, 185, 193, 193, 193, 183, 183, 172,
   138, 64, 38, 240, 240, 240, 240, 240, 240, 240, 240, 207, 207, 207, 207, 204, 204, 204, 193, 193, 180, 143, 66, 40, 185, 185, 185, 185, 185, 185,
   185, 185, 193, 193, 193, 193, 193, 193, 193, 183, 183, 172, 138, 65, 39, 207, 207, 207, 207, 207, 207, 207, 207, 204, 204, 204, 204, 201, 201, 201,
   188, 188, 176, 141, 66, 40, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 194, 194, 194, 184, 184, 173, 139, 65, 39, 204, 204, 204,
   204, 204, 204, 204, 204, 201, 201, 201, 201, 198, 198, 198, 187, 187, 175, 140, 66, 40
};
static const twiddle_cpx fft_twiddles[] = {
   {1.0000000f, -0.0000000f}, {0.99991433f, -0.013089596f}, {0.99965732f, -0.026176948f}, {0.99922904f, -0.039259816f},
   {0.99862953f, -0.052335956f}, {0.99785892f, -0.065403129f}, {0.99691733f, -0.078459096f}, {0.99580493f, -0.091501619f},
   {0.99452190f, -0.10452846f}, {0.99306846f, -0.11753740f}, {0.99144486f, -0.13052619f}, {0.98965139f, -0.14349262f},
   {0.98768834f, -0.15643447f}, {0.98555606f, -0.16934950f}, {0.98325491f, -0.18223553f}, {0.98078528f, -0.19509032f},
   {0.97814760f, -0.20791169f}, {0.97534232f, -0.22069744f}, {0.97236992f, -0.23344536f}, {0.96923091f, -0.24615329f},
   {0.96592583f, -0.25881905f}, {0.96245524f, -0.27144045f}, {0.95881973f, -0.28401534f}, {0.95501994f, -0.29654157f},
   {0.95105652f, -0.30901699f}, {0.94693013f, -0.32143947f}, {0.94264149f, -0.33380686f}, {0.93819134f, -0.34611706f},
   {0.93358043f, -0.35836795f}, {0.92880955f, -0.37055744f}, {0.92387953f, -0.38268343f}, {0.91879121f, -0.39474386f},
   {0.91354546f, -0.40673664f}, {0.90814317f, -0.41865974f}, {0.90258528f, -0.43051110f}, {0.89687274f, -0.44228869f},
   {0.89100652f, -0.45399050f}, {0.88498764f, -0.46561452f}, {0.87881711f, -0.47715876f}, {0.87249601f, -0.48862124f},
   {0.86602540f, -0.50000000f}, {0.85940641f, -0.51129309f}, {0.85264016f, -0.52249856f}, {0.84572782f, -0.53361452f},
   {0.83867057f, -0.54463904f}, {0.83146961f, -0.55557023f}, {0.82412619f, -0.56640624f}, {0.81664156f, -0.57714519f},
   {0.80901699f, -0.58778525f}, {0.80125381f, -0.59832460f}, {0.79335334f, -0.60876143f}, {0.78531693f, -0.61909395f},
   {0.77714596f, -0.62932039f}, {0.76884183f, -0.63943900f}, {0.76040597f, -0.64944805f}, {0.75183981f, -0.65934582f},
   {0.74314483f, -0.66913061f}, {0.73432251f, -0.67880075f}, {0.72537437f, -0.68835458f}, {0.71630194f, -0.69779046f},
   {0.70710678f, -0.70710678f}, {0.69779046f, -0.71630194f}, {0.68835458f, -0.72537437f}, {0.67880075f, -0.73432251f},
   {0.66913061f, -0.74314483f}, {0.65934582f, -0.75183981f}, {0.64944805f, -0.76040597f}, {0.63943900f, -0.76884183f},
   {0.62932039f, -0.77714596f}, {0.61909395f, -0.78531693f}, {0.60876143f, -0.79335334f}, {0.59832460f, -0.80125381f},
   {0.58778525f, -0.80901699f}, {0.57714519f, -0.81664156f}, {0.56640624f, -0.82412619f}, {0.55557023f, -0.83146961f},
   {0.54463904f, -0.83867057f}, {0.53361452f, -0.84572782f}, {0.52249856f, -0.85264016f}, {0.51129309f, -0.85940641f},
   {0.50000000f, -0.86602540f}, {0.48862124f, -0.87249601f}, {0.47715876f, -0.87881711f}, {0.46561452f, -0.88498764f},
   {0.45399050f, -0.89100652f}, {0.44228869f, -0.89687274f}, {0.43051110f, -0.90258528f}, {0.41865974f, -0.90814317f},
   {0.40673664f, -0.91354546f}, {0.39474386f, -0.91879121f}, {0.38268343f, -0.92387953f}, {0.37055744f, -0.92880955f},
   {0.35836795f, -0.93358043f}, {0.34611706f, -0.93819134f}, {0.33380686f, -0.94264149f}, {0.32143947f, -0.94693013f},
   {0.30901699f, -0.95105652f}, {0.29654157f, -0.95501994f}, {0.28401534f, -0.95881973f}, {0.27144045f, -0.96245524f},
   {0.25881905f, -0.96592583f}, {0.24615329f, -0.96923091f}, {0.23344536f, -0.97236992f}, {0.22069744f, -0.97534232f},
   {0.20791169f, -0.97814760f}, {0.19509032f, -0.98078528f}, {0.18223553f, -0.98325491f}, {0.16934950f, -0.98555606f},
   {0.15643447f, -0.98768834f}, {0.14349262f, -0.98965139f}, {0.13052619f, -0.99144486f}, {0.11753740f, -0.99306846f},
   {0.10452846f, -0.99452190f}, {0.091501619f, -0.99580493f}, {0.078459096f, -0.99691733f}, {0.065403129f, -0.99785892f},
   {0.052335956f, -0.99862953f}, {0.039259816f, -0.99922904f}, {0.026176948f, -0.99965732f}, {0.013089596f, -0.99991433f},
   {6.1230318e-17f, -1.0000000f}, {-0.013089596f, -0.99991433f}, {-0.026176948f, -0.99965732f}, {-0.039259816f, -0.99922904f},
   {-0.052335956f, -0.99862953f}, {-0.065403129f, -0.99785892f}, {-0.078459096f, -0.99691733f}, {-0.091501619f, -0.99580493f},
   {-0.10452846f, -0.99452190f}, {-0.11753740f, -0.99306846f}, {-0.13052619f, -0.99144486f}, {-0.14349262f, -0.98965139f},
   {-0.15643447f, -0.98768834f}, {-0.16934950f, -0.98555606f}, {-0.18223553f, -0.98325491f}, {-0.19509032f, -0.98078528f},
   {-0.20791169f, -0.97814760f}, {-0.22069744f, -0.97534232f}, {-0.23344536f, -0.97236992f}, {-0.24615329f, -0.96923091f},
   {-0.25881905f, -0.96592583f}, {-0.27144045f, -0.96245524f}, {-0.28401534f, -0.95881973f}, {-0.29654157f, -0.95501994f},
   {-0.30901699f, -0.95105652f}, {-0.32143947f, -0.94693013f}, {-0.33380686f, -0.94264149f}, {-0.34611706f, -0.93819134f},
   {-0.35836795f, -0.93358043f}, {-0.37055744f, -0.92880955f}, {-0.38268343f, -0.92387953f}, {-0.39474386f, -0.91879121f},
   {-0.40673664f, -0.91354546f}, {-0.41865974f, -0.90814317f}, {-0.43051110f, -0.90258528f}, {-0.44228869f, -0.89687274f},
   {-0.45399050f, -0.89100652f}, {-0.46561452f, -0.88498764f}, {-0.47715876f, -0.87881711f}, {-0.48862124f, -0.87249601f},
   {-0.50000000f, -0.86602540f}, {-0.51129309f, -0.85940641f}, {-0.52249856f, -0.85264016f}, {-0.53361452f, -0.84572782f},
   {-0.54463904f, -0.83867057f}, {-0.55557023f, -0.83146961f}, {-0.56640624f, -0.82412619f}, {-0.57714519f, -0.81664156f},
   {-0.58778525f, -0.80901699f}, {-0.59832460f, -0.80125381f}, {-0.60876143f, -0.79335334f}, {-0.61909395f, -0.78531693f},
   {-0.62932039f, -0.77714596f}, {-0.63943900f, -0.76884183f}, {-0.64944805f, -0.76040597f}, {-0.65934582f, -0.75183981f},
   {-0.66913061f, -0.74314483f}, {-0.67880075f, -0.73432251f}, {-0.68835458f, -0.72537437f}, {-0.69779046f, -0.71630194f},
   {-0.70710678f, -0.70710678f}, {-0.71630194f, -0.69779046f}, {-0.72537437f, -0.68835458f}, {-0.73432251f, -0.67880075f},
   {-0.74314483f, -0.66913061f}, {-0.75183981f, -0.65934582f}, {-0.76040597f, -0.64944805f}, {-0.76884183f, -0.63943900f},
   {-0.77714596f, -0.62932039f}, {-0.78531693f, -0.61909395f}, {-0.79335334f, -0.60876143f}, {-0.80125381f, -0.59832460f},
   {-0.80901699f, -0.58778525f}, {-0.81664156f, -0.57714519f}, {-0.82412619f, -0.56640624f}, {-0.83146961f, -0.55557023f},
   {-0.83867057f, -0.54463904f}, {-0.84572782f, -0.53361452f}, {-0.85264016f, -0.52249856f}, {-0.85940641f, -0.51129309f},
   {-0.86602540f, -0.50000000f}, {-0.87249601f, -0.48862124f}, {-0.87881711f, -0.47715876f}, {-0.88498764f, -0.46561452f},
   {-0.89100652f, -0.45399050f}, {-0.89687274f, -0.44228869f}, {-0.90258528f, -0.43051110f}, {-0.90814317f, -0.41865974f},
   {-0.91354546f, -0.40673664f}, {-0.91879121f, -0.39474386f}, {-0.92387953f, -0.38268343f}, {-0.92880955f, -0.37055744f},
   {-0.93358043f, -0.35836795f}, {-0.93819134f, -0.34611706f}, {-0.94264149f, -0.33380686f}, {-0.94693013f, -0.32143947f},
   {-0.95105652f, -0.30901699f}, {-0.95501994f, -0.29654157f}, {-0.95881973f, -0.28401534f}, {-0.96245524f, -0.27144045f},
   {-0.96592583f, -0.25881905f}, {-0.96923091f, -0.24615329f}, {-0.97236992f, -0.23344536f}, {-0.97534232f, -0.22069744f},
   {-0.97814760f, -0.20791169f}, {-0.98078528f, -0.19509032f}, {-0.98325491f, -0.18223553f}, {-0.98555606f, -0.16934950f},
   {-0.98768834f, -0.15643447f}, {-0.98965139f, -0.14349262f}, {-0.99144486f, -0.13052619f}, {-0.99306846f, -0.11753740f},
   {-0.99452190f, -0.10452846f}, {-0.99580493f, -0.091501619f}, {-0.99691733f, -0.078459096f}, {-0.99785892f, -0.065403129f},
   {-0.99862953f, -0.052335956f}, {-0.99922904f, -0.039259816f}, {-0.99965732f, -0.026176948f}, {-0.99991433f, -0.013089596f},
   {-1.0000000f, -1.2246064e-16f}, {-0.99991433f, 0.013089596f}, {-0.99965732f, 0.026176948f}, {-0.99922904f, 0.039259816f},
   {-0.99862953f, 0.052335956f}, {-0.99785892f, 0.065403129f}, {-0.99691733f, 0.078459096f}, {-0.99580493f, 0.091501619f},
   {-0.99452190f, 0.10452846f}, {-0.99306846f, 0.11753740f}, {-0.99144486f, 0.13052619f}, {-0.98965139f, 0.14349262f},
   {-0.98768834f, 0.15643447f}, {-0.98555606f, 0.16934950f}, {-0.98325491f, 0.18223553f}, {-0.98078528f, 0.19509032f},
   {-0.97814760f, 0.20791169f}, {-0.97534232f, 0.22069744f}, {-0.97236992f, 0.23344536f}, {-0.96923091f, 0.24615329f},
   {-0.96592583f, 0.25881905f}, {-0.96245524f, 0.27144045f}, {-0.95881973f, 0.28401534f}, {-0.95501994f, 0.29654157f},
   {-0.95105652f, 0.30901699f}, {-0.94693013f, 0.32143947f}, {-0.94264149f, 0.33380686f}, {-0.93819134f, 0.34611706f},
   {-0.93358043f, 0.35836795f}, {-0.92880955f, 0.37055744f}, {-0.92387953f, 0.38268343f}, {-0.91879121f, 0.39474386f},
   {-0.91354546f, 0.40673664f}, {-0.90814317f, 0.41865974f}, {-0.90258528f, 0.43051110f}, {-0.89687274f, 0.44228869f},
   {-0.89100652f, 0.45399050f}, {-0.88498764f, 0.46561452f}, {-0.87881711f, 0.47715876f}, {-0.87249601f, 0.48862124f},
   {-0.86602540f, 0.50000000f}, {-0.85940641f, 0.51129309f}, {-0.85264016f, 0.52249856f}, {-0.84572782f, 0.53361452f},
   {-0.83867057f, 0.54463904f}, {-0.83146961f, 0.55557023f}, {-0.82412619f, 0.56640624f}, {-0.81664156f, 0.57714519f},
   {-0.80901699f, 0.58778525f}, {-0.80125381f, 0.59832460f}, {-0.79335334f, 0.60876143f}, {-0.78531693f, 0.61909395f},
   {-0.77714596f, 0.62932039f}, {-0.76884183f, 0.63943900f}, {-0.76040597f, 0.64944805f}, {-0.75183981f, 0.65934582f},
   {-0.74314483f, 0.66913061f}, {-0.73432251f, 0.67880075f}, {-0.72537437f, 0.68835458f}, {-0.71630194f, 0.69779046f},
   {-0.70710678f, 0.70710678f}, {-0.69779046f, 0.71630194f}, {-0.68835458f, 0.72537437f}, {-0.67880075f, 0.73432251f},
   {-0.66913061f, 0.74314483f}, {-0.65934582f, 0.75183981f}, {-0.64944805f, 0.76040597f}, {-0.63943900f, 0.76884183f},
   {-0.62932039f, 0.77714596f}, {-0.61909395f, 0.78531693f}, {-0.60876143f, 0.79335334f}, {-0.59832460f, 0.80125381f},
   {-0.58778525f, 0.80901699f}, {-0.57714519f, 0.81664156f}, {-0.56640624f, 0.82412619f}, {-0.55557023f, 0.83146961f},
   {-0.54463904f, 0.83867057f}, {-0.53361452f, 0.84572782f}, {-0.52249856f, 0.85264016f}, {-0.51129309f, 0.85940641f},
   {-0.50000000f, 0.86602540f}, {-0.48862124f, 0.87249601f}, {-0.47715876f, 0.87881711f}, {-0.46561452f, 0.88498764f},
   {-0.45399050f, 0.89100652f}, {-0.44228869f, 0.89687274f}, {-0.43051110f, 0.90258528f}, {-0.41865974f, 0.90814317f},
   {-0.40673664f, 0.91354546f}, {-0.39474386f, 0.91879121f}, {-0.38268343f, 0.92387953f}, {-0.37055744f, 0.92880955f},
   {-0.35836795f, 0.93358043f}, {-0.34611706f, 0.93819134f}, {-0.33380686f, 0.94264149f}, {-0.32143947f, 0.94693013f},
   {-0.30901699f, 0.95105652f}, {-0.29654157f, 0.95501994f}, {-0.28401534f, 0.95881973f}, {-0.27144045f, 0.96245524f},
   {-0.25881905f, 0.96592583f}, {-0.24615329f, 0.96923091f}, {-0.23344536f, 0.97236992f}, {-0.22069744f, 0.97534232f},
   {-0.20791169f, 0.97814760f}, {-0.19509032f, 0.98078528f}, {-0.18223553f, 0.98325491f}, {-0.16934950f, 0.98555606f},
   {-0.15643447f, 0.98768834f}, {-0.14349262f, 0.98965139f}, {-0.13052619f, 0.99144486f}, {-0.11753740f, 0.99306846f},
   {-0.10452846f, 0.99452190f}, {-0.091501619f, 0.99580493f}, {-0.078459096f, 0.99691733f}, {-0.065403129f, 0.99785892f},
   {-0.052335956f, 0.99862953f}, {-0.039259816f, 0.99922904f}, {-0.026176948f, 0.99965732f}, {-0.013089596f, 0.99991433f},
   {-1.8369095e-16f, 1.0000000f}, {0.013089596f, 0.99991433f}, {0.026176948f, 0.99965732f}, {0.039259816f, 0.99922904f},
   {0.052335956f, 0.99862953f}, {0.065403129f, 0.99785892f}, {0.078459096f, 0.99691733f}, {0.091501619f, 0.99580493f},
   {0.10452846f, 0.99452190f}, {0.11753740f, 0.99306846f}, {0.13052619f, 0.99144486f}, {0.14349262f, 0.98965139f},
   {0.15643447f, 0.98768834f}, {0.16934950f, 0.98555606f}, {0.18223553f, 0.98325491f}, {0.19509032f, 0.98078528f},
   {0.20791169f, 0.97814760f}, {0.22069744f, 0.97534232f}, {0.23344536f, 0.97236992f}, {0.24615329f, 0.96923091f},
   {0.25881905f, 0.96592583f}, {0.27144045f, 0.96245524f}, {0.28401534f, 0.95881973f}, {0.29654157f, 0.95501994f},
   {0.30901699f, 0.95105652f}, {0.32143947f, 0.94693013f}, {0.33380686f, 0.94264149f}, {0.34611706f, 0.93819134f},
   {0.35836795f, 0.93358043f}, {0.37055744f, 0.92880955f}, {0.38268343f, 0.92387953f}, {0.39474386f, 0.91879121f},
   {0.40673664f, 0.91354546f}, {0.41865974f, 0.90814317f}, {0.43051110f, 0.90258528f}, {0.44228869f, 0.89687274f},
   {0.45399050f, 0.89100652f}, {0.46561452f, 0.88498764f}, {0.47715876f, 0.87881711f}, {0.48862124f, 0.87249601f},
   {0.50000000f, 0.86602540f}, {0.51129309f, 0.85940641f}, {0.52249856f, 0.85264016f}, {0.53361452f, 0.84572782f},
   {0.54463904f, 0.83867057f}, {0.55557023f, 0.83146961f}, {0.56640624f, 0.82412619f}, {0.57714519f, 0.81664156f},
   {0.58778525f, 0.80901699f}, {0.59832460f, 0.80125381f}, {0.60876143f, 0.79335334f}, {0.61909395f, 0.78531693f},
   {0.62932039f, 0.77714596f}, {0.63943900f, 0.76884183f}, {0.64944805f, 0.76040597f}, {0.65934582f, 0.75183981f},
   {0.66913061f, 0.74314483f}, {0.67880075f, 0.73432251f}, {0.68835458f, 0.72537437f}, {0.69779046f, 0.71630194f},
   {0.70710678f, 0.70710678f}, {0.71630194f, 0.69779046f}, {0.72537437f, 0.68835458f}, {0.73432251f, 0.67880075f},
   {0.74314483f, 0.66913061f}, {0.75183981f, 0.65934582f}, {0.76040597f, 0.64944805f}, {0.76884183f, 0.63943900f},
   {0.77714596f, 0.62932039f}, {0.78531693f, 0.61909395f}, {0.79335334f, 0.60876143f}, {0.80125381f, 0.59832460f},
   {0.80901699f, 0.58778525f}, {0.81664156f, 0.57714519f}, {0.82412619f, 0.56640624f}, {0.83146961f, 0.55557023f},
   {0.83867057f, 0.54463904f}, {0.84572782f, 0.53361452f}, {0.85264016f, 0.52249856f}, {0.85940641f, 0.51129309f},
   {0.86602540f, 0.50000000f}, {0.87249601f, 0.48862124f}, {0.87881711f, 0.47715876f}, {0.88498764f, 0.46561452f},
   {0.89100652f, 0.45399050f}, {0.89687274f, 0.44228869f}, {0.90258528f, 0.43051110f}, {0.90814317f, 0.41865974f},
   {0.91354546f, 0.40673664f}, {0.91879121f, 0.39474386f}, {0.92387953f, 0.38268343f}, {0.92880955f, 0.37055744f},
   {0.93358043f, 0.35836795f}, {0.93819134f, 0.34611706f}, {0.94264149f, 0.33380686f}, {0.94693013f, 0.32143947f},
   {0.95105652f, 0.30901699f}, {0.95501994f, 0.29654157f}, {0.95881973f, 0.28401534f}, {0.96245524f, 0.27144045f},
   {0.96592583f, 0.25881905f}, {0.96923091f, 0.24615329f}, {0.97236992f, 0.23344536f}, {0.97534232f, 0.22069744f},
   {0.97814760f, 0.20791169f}, {0.98078528f, 0.19509032f}, {0.98325491f, 0.18223553f}, {0.98555606f, 0.16934950f},
   {0.98768834f, 0.15643447f}, {0.98965139f, 0.14349262f}, {0.99144486f, 0.13052619f}, {0.99306846f, 0.11753740f},
   {0.99452190f, 0.10452846f}, {0.99580493f, 0.091501619f}, {0.99691733f, 0.078459096f}, {0.99785892f, 0.065403129f},
   {0.99862953f, 0.052335956f}, {0.99922904f, 0.039259816f}, {0.99965732f, 0.026176948f}, {0.99991433f, 0.013089596f},
};
static const opus_int16 fft_bitrev[] = {
   0, 96, 192, 288, 384, 32, 128, 224, 320, 416, 64, 160, 256, 352, 448, 8, 104, 200, 296, 392, 40, 136, 232, 328, 424, 72, 168, 264, 360, 456,
   16, 112, 208, 304, 400, 48, 144, 240, 336, 432, 80, 176, 272, 368, 464, 24, 120, 216, 312, 408, 56, 152, 248, 344, 440, 88, 184, 280, 376, 472,
   4, 100, 196, 292, 388, 36, 132, 228, 324, 420, 68, 164, 260, 356, 452, 12, 108, 204, 300, 396, 44, 140, 236, 332, 428, 76, 172, 268, 364, 460,
   20, 116, 212, 308, 404, 52, 148, 244, 340, 436, 84, 180, 276, 372, 468, 28, 124, 220, 316, 412, 60, 156, 252, 348, 444, 92, 188, 284, 380, 476,
   1, 97, 193, 289, 385, 33, 129, 225, 321, 417, 65, 161, 257, 353, 449, 9, 105, 201, 297, 393, 41, 137, 233, 329, 425, 73, 169, 265, 361, 457,
   17, 113, 209, 305, 401, 49, 145, 241, 337, 433, 81, 177, 273, 369, 465, 25, 121, 217, 313, 409, 57, 153, 249, 345, 441, 89, 185, 281, 377, 473,
   5, 101, 197, 293, 389, 37, 133, 229, 325, 421, 69, 165, 261, 357, 453, 13, 109, 205, 301, 397, 45, 141, 237, 333, 429, 77, 173, 269, 365, 461,
   21, 117, 213, 309, 405, 53, 149, 245, 341, 437, 85, 181, 277, 373, 469, 29, 125, 221, 317, 413, 61, 157, 253, 349, 445, 93, 189, 285, 381, 477,
   2, 98, 194, 290, 386, 34, 130, 226, 322, 418, 66, 162, 258, 354, 450, 10, 106, 202, 298, 394, 42, 138, 234, 330, 426, 74, 170, 266, 362, 458,
   18, 114, 210, 306, 402, 50, 146, 242, 338, 434, 82, 178, 274, 370, 466, 26, 122, 218, 314, 410, 58, 154, 250, 346, 442, 90, 186, 282, 378, 474,
   6, 102, 198, 294, 390, 38, 134, 230, 326, 422, 70, 166, 262, 358, 454, 14, 110, 206, 302, 398, 46, 142, 238, 334, 430, 78, 174, 270, 366, 462,
   22, 118, 214, 310, 406, 54, 150, 246, 342, 438, 86, 182, 278, 374, 470, 30, 126, 222, 318, 414, 62, 158, 254, 350, 446, 94, 190, 286, 382, 478,
   3, 99, 195, 291, 387, 35, 131, 227, 323, 419, 67, 163, 259, 355, 451, 11, 107, 203, 299, 395, 43, 139, 235, 331, 427, 75, 171, 267, 363, 459,
   19, 115, 211, 307, 403, 51, 147, 243, 339, 435, 83, 179, 275, 371, 467, 27, 123, 219, 315, 411, 59, 155, 251, 347, 443, 91, 187, 283, 379, 475,
   7, 103, 199, 295, 391, 39, 135, 231, 327, 423, 71, 167, 263, 359, 455, 15, 111, 207, 303, 399, 47, 143, 239, 335, 431, 79, 175, 271, 367, 463,
   23, 119, 215, 311, 407, 55, 151, 247, 343, 439, 87, 183, 279, 375, 471, 31, 127, 223, 319, 415, 63, 159, 255, 351, 447, 95, 191, 287, 383, 479,
};
static const float mdct_twiddles[] = {
   0.99999994f, 0.99999321f, 0.99997580f, 0.99994773f, 0.99990886f, 0.99985933f, 0.99979913f, 0.99972820f, 0.99964654f, 0.99955416f,
   0.99945110f, 0.99933738f, 0.99921292f, 0.99907774f, 0.99893188f, 0.99877530f, 0.99860805f, 0.99843007f, 0.99824142f, 0.99804211f,
   0.99783206f, 0.99761140f, 0.99737996f, 0.99713790f, 0.99688518f, 0.99662173f, 0.99634761f, 0.99606287f, 0.99576741f, 0.99546129f,
   0.99514455f, 0.99481714f, 0.99447906f, 0.99413031f, 0.99377096f, 0.99340093f, 0.99302030f, 0.99262899f, 0.99222708f, 0.99181455f,
   0.99139136f, 0.99095762f, 0.99051321f, 0.99005818f, 0.98959261f, 0.98911643f, 0.98862964f, 0.98813224f, 0.98762429f, 0.98710573f,
   0.98657662f, 0.98603696f, 0.98548669f, 0.98492593f, 0.98435456f, 0.98377270f, 0.98318028f, 0.98257732f, 0.98196387f, 0.98133987f,
   0.98070538f, 0.98006040f, 0.97940493f, 0.97873890f, 0.97806245f, 0.97737551f, 0.97667813f, 0.97597027f, 0.97525197f, 0.97452319f,
   0.97378403f, 0.97303438f, 0.97227436f, 0.97150391f, 0.97072303f, 0.96993178f, 0.96913016f, 0.96831810f, 0.96749574f, 0.96666300f,
   0.96581990f, 0.96496642f, 0.96410263f, 0.96322852f, 0.96234411f, 0.96144938f, 0.96054435f, 0.95962906f, 0.95870346f, 0.95776761f,
   0.95682150f, 0.95586514f, 0.95489854f, 0.95392174f, 0.95293468f, 0.95193744f, 0.95093000f, 0.94991243f, 0.94888461f, 0.94784665f,
   0.94679856f, 0.94574034f, 0.94467193f, 0.94359344f, 0.94250488f, 0.94140619f, 0.94029742f, 0.93917859f, 0.93804967f, 0.93691075f,
   0.93576175f, 0.93460274f, 0.93343377f, 0.93225473f, 0.93106574f, 0.92986679f, 0.92865789f, 0.92743903f, 0.92621022f, 0.92497152f,
   0.92372292f, 0.92246443f, 0.92119598f, 0.91991776f, 0.91862965f, 0.91733170f, 0.91602397f, 0.91470635f, 0.91337901f, 0.91204184f,
   0.91069490f, 0.90933824f, 0.90797186f, 0.90659571f, 0.90520984f, 0.90381432f, 0.90240908f, 0.90099424f, 0.89956969f, 0.89813554f,
   0.89669174f, 0.89523834f, 0.89377540f, 0.89230281f, 0.89082074f, 0.88932908f, 0.88782793f, 0.88631725f, 0.88479710f, 0.88326746f,
   0.88172835f, 0.88017982f, 0.87862182f, 0.87705445f, 0.87547767f, 0.87389153f, 0.87229604f, 0.87069118f, 0.86907703f, 0.86745358f,
   0.86582077f, 0.86417878f, 0.86252749f, 0.86086690f, 0.85919720f, 0.85751826f, 0.85583007f, 0.85413277f, 0.85242635f, 0.85071075f,
   0.84898609f, 0.84725231f, 0.84550947f, 0.84375757f, 0.84199661f, 0.84022665f, 0.83844769f, 0.83665979f, 0.83486289f, 0.83305705f,
   0.83124226f, 0.82941860f, 0.82758605f, 0.82574469f, 0.82389444f, 0.82203537f, 0.82016748f, 0.81829083f, 0.81640542f, 0.81451124f,
   0.81260836f, 0.81069672f, 0.80877650f, 0.80684757f, 0.80490994f, 0.80296379f, 0.80100900f, 0.79904562f, 0.79707366f, 0.79509324f,
   0.79310423f, 0.79110676f, 0.78910083f, 0.78708643f, 0.78506362f, 0.78303236f, 0.78099275f, 0.77894479f, 0.77688843f, 0.77482378f,
   0.77275085f, 0.77066964f, 0.76858020f, 0.76648247f, 0.76437658f, 0.76226246f, 0.76014024f, 0.75800985f, 0.75587130f, 0.75372469f,
   0.75157005f, 0.74940729f, 0.74723655f, 0.74505776f, 0.74287105f, 0.74067634f, 0.73847371f, 0.73626316f, 0.73404479f, 0.73181850f,
   0.72958434f, 0.72734243f, 0.72509271f, 0.72283524f, 0.72057003f, 0.71829706f, 0.71601641f, 0.71372813f, 0.71143216f, 0.70912862f,
   0.70681745f, 0.70449871f, 0.70217246f, 0.69983864f, 0.69749737f, 0.69514859f, 0.69279242f, 0.69042879f, 0.68805778f, 0.68567938f,
   0.68329364f, 0.68090063f, 0.67850029f, 0.67609268f, 0.67367786f, 0.67125577f, 0.66882652f, 0.66639012f, 0.66394657f, 0.66149592f,
   0.65903819f, 0.65657341f, 0.65410155f, 0.65162271f, 0.64913690f, 0.64664418f, 0.64414448f, 0.64163786f, 0.63912445f, 0.63660413f,
   0.63407701f, 0.63154310f, 0.62900239f, 0.62645501f, 0.62390089f, 0.62134010f, 0.61877263f, 0.61619854f, 0.61361790f, 0.61103064f,
   0.60843682f, 0.60583651f, 0.60322970f, 0.60061646f, 0.59799677f, 0.59537065f, 0.59273821f, 0.59009939f, 0.58745426f, 0.58480281f,
   0.58214509f, 0.57948118f, 0.57681108f, 0.57413477f, 0.57145232f, 0.56876373f, 0.56606907f, 0.56336832f, 0.56066155f, 0.55794877f,
   0.55523002f, 0.55250537f, 0.54977477f, 0.54703826f, 0.54429591f, 0.54154772f, 0.53879374f, 0.53603399f, 0.53326851f, 0.53049731f,
   0.52772039f, 0.52493787f, 0.52214974f, 0.51935595f, 0.51655668f, 0.51375180f, 0.51094145f, 0.50812566f, 0.50530440f, 0.50247771f,
   0.49964568f, 0.49680826f, 0.49396557f, 0.49111754f, 0.48826426f, 0.48540577f, 0.48254207f, 0.47967321f, 0.47679919f, 0.47392011f,
   0.47103590f, 0.46814668f, 0.46525243f, 0.46235323f, 0.45944905f, 0.45653993f, 0.45362595f, 0.45070711f, 0.44778344f, 0.44485497f,
   0.44192174f, 0.43898380f, 0.43604112f, 0.43309379f, 0.43014181f, 0.42718524f, 0.42422408f, 0.42125839f, 0.41828820f, 0.41531351f,
   0.41233435f, 0.40935081f, 0.40636289f, 0.40337059f, 0.40037400f, 0.39737311f, 0.39436796f, 0.39135858f, 0.38834500f, 0.38532731f,
   0.38230544f, 0.37927949f, 0.37624949f, 0.37321547f, 0.37017745f, 0.36713544f, 0.36408952f, 0.36103970f, 0.35798600f, 0.35492846f,
   0.35186714f, 0.34880206f, 0.34573323f, 0.34266070f, 0.33958447f, 0.33650464f, 0.33342120f, 0.33033419f, 0.32724363f, 0.32414958f,
   0.32105204f, 0.31795108f, 0.31484672f, 0.31173897f, 0.30862790f, 0.30551350f, 0.30239585f, 0.29927495f, 0.29615086f, 0.29302359f,
   0.28989318f, 0.28675964f, 0.28362307f, 0.28048345f, 0.27734083f, 0.27419522f, 0.27104670f, 0.26789525f, 0.26474094f, 0.26158381f,
   0.25842386f, 0.25526115f, 0.25209570f, 0.24892756f, 0.24575676f, 0.24258332f, 0.23940729f, 0.23622867f, 0.23304754f, 0.22986393f,
   0.22667783f, 0.22348931f, 0.22029841f, 0.21710514f, 0.21390954f, 0.21071166f, 0.20751151f, 0.20430915f, 0.20110460f, 0.19789790f,
   0.19468907f, 0.19147816f, 0.18826519f, 0.18505022f, 0.18183327f, 0.17861435f, 0.17539354f, 0.17217083f, 0.16894630f, 0.16571994f,
   0.16249183f, 0.15926196f, 0.15603039f, 0.15279715f, 0.14956227f, 0.14632578f, 0.14308774f, 0.13984816f, 0.13660708f, 0.13336454f,
   0.13012058f, 0.12687522f, 0.12362850f, 0.12038045f, 0.11713112f, 0.11388054f, 0.11062872f, 0.10737573f, 0.10412160f, 0.10086634f,
   0.097609997f, 0.094352618f, 0.091094226f, 0.087834857f, 0.084574550f, 0.081313334f, 0.078051247f, 0.074788325f, 0.071524605f, 0.068260118f,
   0.064994894f, 0.061728980f, 0.058462404f, 0.055195201f, 0.051927410f, 0.048659060f, 0.045390189f, 0.042120833f, 0.038851023f, 0.035580799f,
   0.032310195f, 0.029039243f, 0.025767982f, 0.022496443f, 0.019224664f, 0.015952680f, 0.012680525f, 0.0094082337f, 0.0061358409f, 0.0028633832f,
   -0.00040910527f, -0.0036815894f, -0.0069540343f, -0.010226404f, -0.013498665f, -0.016770782f, -0.020042717f, -0.023314439f, -0.026585912f, -0.029857099f,
   -0.033127967f, -0.036398482f, -0.039668605f, -0.042938303f, -0.046207540f, -0.049476285f, -0.052744497f, -0.056012146f, -0.059279196f, -0.062545612f,
   -0.065811358f, -0.069076397f, -0.072340697f, -0.075604223f, -0.078866936f, -0.082128808f, -0.085389800f, -0.088649876f, -0.091909006f, -0.095167145f,
   -0.098424271f, -0.10168034f, -0.10493532f, -0.10818918f, -0.11144188f, -0.11469338f, -0.11794366f, -0.12119267f, -0.12444039f, -0.12768677f,
   -0.13093179f, -0.13417540f, -0.13741758f, -0.14065829f, -0.14389749f, -0.14713514f, -0.15037122f, -0.15360570f, -0.15683852f, -0.16006967f,
   -0.16329910f, -0.16652679f, -0.16975269f, -0.17297678f, -0.17619900f, -0.17941935f, -0.18263777f, -0.18585424f, -0.18906870f, -0.19228116f,
   -0.19549155f, -0.19869985f, -0.20190603f, -0.20511003f, -0.20831184f, -0.21151142f, -0.21470875f, -0.21790376f, -0.22109644f, -0.22428675f,
   -0.22747467f, -0.23066014f, -0.23384315f, -0.23702365f, -0.24020162f, -0.24337701f, -0.24654980f, -0.24971995f, -0.25288740f, -0.25605217f,
   -0.25921419f, -0.26237345f, -0.26552987f, -0.26868346f, -0.27183419f, -0.27498198f, -0.27812684f, -0.28126872f, -0.28440759f, -0.28754342f,
   -0.29067615f, -0.29380578f, -0.29693225f, -0.30005556f, -0.30317566f, -0.30629250f, -0.30940607f, -0.31251630f, -0.31562322f, -0.31872672f,
   -0.32182685f, -0.32492352f, -0.32801670f, -0.33110636f, -0.33419248f, -0.33727503f, -0.34035397f, -0.34342924f, -0.34650084f, -0.34956875f,
   -0.35263291f, -0.35569328f, -0.35874987f, -0.36180258f, -0.36485144f, -0.36789638f, -0.37093741f, -0.37397444f, -0.37700745f, -0.38003644f,
   -0.38306138f, -0.38608220f, -0.38909888f, -0.39211139f, -0.39511973f, -0.39812380f, -0.40112361f, -0.40411916f, -0.40711036f, -0.41009718f,
   -0.41307965f, -0.41605768f, -0.41903123f, -0.42200032f, -0.42496487f, -0.42792490f, -0.43088034f, -0.43383113f, -0.43677729f, -0.43971881f,
   -0.44265559f, -0.44558764f, -0.44851488f, -0.45143735f, -0.45435500f, -0.45726776f, -0.46017563f, -0.46307856f, -0.46597654f, -0.46886954f,
   -0.47175750f, -0.47464043f, -0.47751826f, -0.48039100f, -0.48325855f, -0.48612097f, -0.48897815f, -0.49183011f, -0.49467680f, -0.49751821f,
   -0.50035429f, -0.50318497f, -0.50601029f, -0.50883019f, -0.51164466f, -0.51445359f, -0.51725709f, -0.52005500f, -0.52284735f, -0.52563411f,
   -0.52841520f, -0.53119069f, -0.53396046f, -0.53672451f, -0.53948283f, -0.54223537f, -0.54498214f, -0.54772300f, -0.55045801f, -0.55318713f,
   -0.55591035f, -0.55862761f, -0.56133890f, -0.56404412f, -0.56674337f, -0.56943649f, -0.57212353f, -0.57480448f, -0.57747924f, -0.58014780f,
   -0.58281022f, -0.58546633f, -0.58811617f, -0.59075975f, -0.59339696f, -0.59602785f, -0.59865236f, -0.60127044f, -0.60388207f, -0.60648727f,
   -0.60908598f, -0.61167812f, -0.61426371f, -0.61684275f, -0.61941516f, -0.62198097f, -0.62454009f, -0.62709254f, -0.62963831f, -0.63217729f,
   -0.63470948f, -0.63723493f, -0.63975352f, -0.64226526f, -0.64477009f, -0.64726806f, -0.64975911f, -0.65224314f, -0.65472025f, -0.65719032f,
   -0.65965337f, -0.66210932f, -0.66455823f, -0.66700000f, -0.66943461f, -0.67186207f, -0.67428231f, -0.67669535f, -0.67910111f, -0.68149966f,
   -0.68389088f, -0.68627477f, -0.68865126f, -0.69102043f, -0.69338220f, -0.69573659f, -0.69808346f, -0.70042288f, -0.70275480f, -0.70507920f,
   -0.70739603f, -0.70970529f, -0.71200693f, -0.71430099f, -0.71658736f, -0.71886611f, -0.72113711f, -0.72340041f, -0.72565591f, -0.72790372f,
   -0.73014367f, -0.73237586f, -0.73460019f, -0.73681659f, -0.73902518f, -0.74122584f, -0.74341851f, -0.74560326f, -0.74778003f, -0.74994880f,
   -0.75210953f, -0.75426215f, -0.75640678f, -0.75854325f, -0.76067162f, -0.76279181f, -0.76490390f, -0.76700771f, -0.76910341f, -0.77119076f,
   -0.77326995f, -0.77534080f, -0.77740335f, -0.77945763f, -0.78150350f, -0.78354102f, -0.78557014f, -0.78759086f, -0.78960317f, -0.79160696f,
   -0.79360235f, -0.79558921f, -0.79756755f, -0.79953730f, -0.80149853f, -0.80345118f, -0.80539525f, -0.80733067f, -0.80925739f, -0.81117553f,
   -0.81308490f, -0.81498563f, -0.81687760f, -0.81876087f, -0.82063532f, -0.82250100f, -0.82435787f, -0.82620591f, -0.82804507f, -0.82987541f,
   -0.83169687f, -0.83350939f, -0.83531296f, -0.83710766f, -0.83889335f, -0.84067005f, -0.84243774f, -0.84419644f, -0.84594607f, -0.84768665f,
   -0.84941816f, -0.85114056f, -0.85285389f, -0.85455805f, -0.85625303f, -0.85793889f, -0.85961550f, -0.86128294f, -0.86294121f, -0.86459017f,
   -0.86622989f, -0.86786032f, -0.86948150f, -0.87109333f, -0.87269586f, -0.87428904f, -0.87587279f, -0.87744725f, -0.87901229f, -0.88056785f,
   -0.88211405f, -0.88365078f, -0.88517809f, -0.88669586f, -0.88820416f, -0.88970292f, -0.89119220f, -0.89267188f, -0.89414203f, -0.89560264f,
   -0.89705360f, -0.89849502f, -0.89992678f, -0.90134889f, -0.90276134f, -0.90416414f, -0.90555727f, -0.90694070f, -0.90831441f, -0.90967834f,
   -0.91103262f, -0.91237706f, -0.91371179f, -0.91503674f, -0.91635185f, -0.91765714f, -0.91895264f, -0.92023826f, -0.92151409f, -0.92277998f,
   -0.92403603f, -0.92528218f, -0.92651838f, -0.92774469f, -0.92896110f, -0.93016750f, -0.93136400f, -0.93255049f, -0.93372697f, -0.93489349f,
   -0.93604994f, -0.93719643f, -0.93833286f, -0.93945926f, -0.94057560f, -0.94168180f, -0.94277799f, -0.94386405f, -0.94494003f, -0.94600588f,
   -0.94706154f, -0.94810712f, -0.94914252f, -0.95016778f, -0.95118284f, -0.95218778f, -0.95318246f, -0.95416695f, -0.95514119f, -0.95610523f,
   -0.95705903f, -0.95800257f, -0.95893586f, -0.95985889f, -0.96077162f, -0.96167403f, -0.96256620f, -0.96344805f, -0.96431959f, -0.96518075f,
   -0.96603161f, -0.96687216f, -0.96770233f, -0.96852213f, -0.96933156f, -0.97013056f, -0.97091925f, -0.97169751f, -0.97246534f, -0.97322279f,
   -0.97396982f, -0.97470641f, -0.97543252f, -0.97614825f, -0.97685349f, -0.97754824f, -0.97823256f, -0.97890645f, -0.97956979f, -0.98022264f,
   -0.98086500f, -0.98149687f, -0.98211825f, -0.98272908f, -0.98332942f, -0.98391914f, -0.98449844f, -0.98506713f, -0.98562527f, -0.98617285f,
   -0.98670989f, -0.98723638f, -0.98775226f, -0.98825759f, -0.98875231f, -0.98923647f, -0.98971003f, -0.99017298f, -0.99062532f, -0.99106705f,
   -0.99149817f, -0.99191868f, -0.99232858f, -0.99272782f, -0.99311644f, -0.99349445f, -0.99386179f, -0.99421853f, -0.99456459f, -0.99489999f,
   -0.99522477f, -0.99553883f, -0.99584228f, -0.99613506f, -0.99641716f, -0.99668860f, -0.99694937f, -0.99719942f, -0.99743885f, -0.99766755f,
   -0.99788558f, -0.99809295f, -0.99828959f, -0.99847561f, -0.99865085f, -0.99881548f, -0.99896932f, -0.99911255f, -0.99924499f, -0.99936682f,
   -0.99947786f, -0.99957830f, -0.99966794f, -0.99974692f, -0.99981517f, -0.99987274f, -0.99991959f, -0.99995571f, -0.99998116f, -0.99999589f,
   0.99999964f, 0.99997288f, 0.99990326f, 0.99979085f, 0.99963558f, 0.99943751f, 0.99919659f, 0.99891287f, 0.99858636f, 0.99821711f,
   0.99780506f, 0.99735034f, 0.99685282f, 0.99631262f, 0.99572974f, 0.99510419f, 0.99443603f, 0.99372530f, 0.99297196f, 0.99217612f,
   0.99133772f, 0.99045694f, 0.98953366f, 0.98856801f, 0.98756003f, 0.98650974f, 0.98541719f, 0.98428243f, 0.98310548f, 0.98188645f,
   0.98062533f, 0.97932225f, 0.97797716f, 0.97659022f, 0.97516143f, 0.97369087f, 0.97217858f, 0.97062469f, 0.96902919f, 0.96739221f,
   0.96571374f, 0.96399397f, 0.96223283f, 0.96043050f, 0.95858705f, 0.95670253f, 0.95477700f, 0.95281059f, 0.95080340f, 0.94875544f,
   0.94666684f, 0.94453770f, 0.94236809f, 0.94015813f, 0.93790787f, 0.93561745f, 0.93328691f, 0.93091643f, 0.92850608f, 0.92605597f,
   0.92356616f, 0.92103678f, 0.91846794f, 0.91585976f, 0.91321236f, 0.91052586f, 0.90780038f, 0.90503591f, 0.90223277f, 0.89939094f,
   0.89651060f, 0.89359182f, 0.89063478f, 0.88763964f, 0.88460642f, 0.88153529f, 0.87842643f, 0.87527996f, 0.87209594f, 0.86887461f,
   0.86561602f, 0.86232042f, 0.85898781f, 0.85561842f, 0.85221243f, 0.84876984f, 0.84529096f, 0.84177583f, 0.83822471f, 0.83463764f,
   0.83101481f, 0.82735640f, 0.82366252f, 0.81993335f, 0.81616908f, 0.81236988f, 0.80853581f, 0.80466717f, 0.80076402f, 0.79682660f,
   0.79285502f, 0.78884947f, 0.78481019f, 0.78073722f, 0.77663082f, 0.77249116f, 0.76831841f, 0.76411277f, 0.75987434f, 0.75560343f,
   0.75130010f, 0.74696463f, 0.74259710f, 0.73819780f, 0.73376691f, 0.72930455f, 0.72481096f, 0.72028631f, 0.71573079f, 0.71114463f,
   0.70652801f, 0.70188117f, 0.69720417f, 0.69249737f, 0.68776089f, 0.68299496f, 0.67819971f, 0.67337549f, 0.66852236f, 0.66364062f,
   0.65873051f, 0.65379208f, 0.64882571f, 0.64383155f, 0.63880974f, 0.63376063f, 0.62868434f, 0.62358117f, 0.61845124f, 0.61329484f,
   0.60811216f, 0.60290343f, 0.59766883f, 0.59240872f, 0.58712316f, 0.58181250f, 0.57647687f, 0.57111657f, 0.56573176f, 0.56032276f,
   0.55488980f, 0.54943299f, 0.54395270f, 0.53844911f, 0.53292239f, 0.52737290f, 0.52180082f, 0.51620632f, 0.51058978f, 0.50495136f,
   0.49929130f, 0.49360985f, 0.48790723f, 0.48218375f, 0.47643960f, 0.47067502f, 0.46489030f, 0.45908567f, 0.45326138f, 0.44741765f,
   0.44155475f, 0.43567297f, 0.42977250f, 0.42385364f, 0.41791660f, 0.41196167f, 0.40598908f, 0.39999911f, 0.39399201f, 0.38796803f,
   0.38192743f, 0.37587047f, 0.36979741f, 0.36370850f, 0.35760403f, 0.35148421f, 0.34534934f, 0.33919969f, 0.33303553f, 0.32685706f,
   0.32066461f, 0.31445843f, 0.30823877f, 0.30200592f, 0.29576012f, 0.28950164f, 0.28323078f, 0.27694780f, 0.27065292f, 0.26434645f,
   0.25802869f, 0.25169984f, 0.24536023f, 0.23901010f, 0.23264973f, 0.22627939f, 0.21989937f, 0.21350993f, 0.20711134f, 0.20070387f,
   0.19428782f, 0.18786344f, 0.18143101f, 0.17499080f, 0.16854310f, 0.16208819f, 0.15562633f, 0.14915779f, 0.14268288f, 0.13620184f,
   0.12971498f, 0.12322257f, 0.11672486f, 0.11022217f, 0.10371475f, 0.097202882f, 0.090686858f, 0.084166944f, 0.077643424f, 0.071116582f,
   0.064586692f, 0.058054037f, 0.051518895f, 0.044981543f, 0.038442269f, 0.031901345f, 0.025359053f, 0.018815678f, 0.012271495f, 0.0057267868f,
   -0.00081816671f, -0.0073630852f, -0.013907688f, -0.020451695f, -0.026994826f, -0.033536803f, -0.040077340f, -0.046616159f, -0.053152986f, -0.059687532f,
   -0.066219524f, -0.072748676f, -0.079274714f, -0.085797355f, -0.092316322f, -0.098831341f, -0.10534211f, -0.11184838f, -0.11834986f, -0.12484626f,
   -0.13133731f, -0.13782275f, -0.14430228f, -0.15077563f, -0.15724251f, -0.16370267f, -0.17015581f, -0.17660165f, -0.18303993f, -0.18947038f,
   -0.19589271f, -0.20230664f, -0.20871192f, -0.21510825f, -0.22149536f, -0.22787298f, -0.23424086f, -0.24059868f, -0.24694622f, -0.25328314f,
   -0.25960925f, -0.26592422f, -0.27222782f, -0.27851975f, -0.28479972f, -0.29106751f, -0.29732284f, -0.30356544f, -0.30979502f, -0.31601134f,
   -0.32221413f, -0.32840309f, -0.33457801f, -0.34073856f, -0.34688455f, -0.35301566f, -0.35913166f, -0.36523229f, -0.37131724f, -0.37738630f,
   -0.38343921f, -0.38947567f, -0.39549544f, -0.40149832f, -0.40748394f, -0.41345215f, -0.41940263f, -0.42533514f, -0.43124944f, -0.43714526f,
   -0.44302234f, -0.44888046f, -0.45471936f, -0.46053877f, -0.46633846f, -0.47211814f, -0.47787762f, -0.48361665f, -0.48933494f, -0.49503228f,
   -0.50070840f, -0.50636309f, -0.51199609f, -0.51760709f, -0.52319598f, -0.52876246f, -0.53430629f, -0.53982723f, -0.54532504f, -0.55079949f,
   -0.55625033f, -0.56167740f, -0.56708032f, -0.57245898f, -0.57781315f, -0.58314258f, -0.58844697f, -0.59372622f, -0.59897995f, -0.60420811f,
   -0.60941035f, -0.61458647f, -0.61973625f, -0.62485951f, -0.62995601f, -0.63502556f, -0.64006782f, -0.64508271f, -0.65007001f, -0.65502942f,
   -0.65996075f, -0.66486382f, -0.66973841f, -0.67458433f, -0.67940134f, -0.68418926f, -0.68894786f, -0.69367695f, -0.69837630f, -0.70304573f,
   -0.70768511f, -0.71229410f, -0.71687263f, -0.72142041f, -0.72593731f, -0.73042315f, -0.73487765f, -0.73930067f, -0.74369204f, -0.74805158f,
   -0.75237900f, -0.75667429f, -0.76093709f, -0.76516730f, -0.76936477f, -0.77352923f, -0.77766061f, -0.78175867f, -0.78582323f, -0.78985411f,
   -0.79385114f, -0.79781419f, -0.80174309f, -0.80563760f, -0.80949765f, -0.81332302f, -0.81711352f, -0.82086903f, -0.82458937f, -0.82827437f,
   -0.83192390f, -0.83553779f, -0.83911592f, -0.84265804f, -0.84616417f, -0.84963393f, -0.85306740f, -0.85646427f, -0.85982448f, -0.86314780f,
   -0.86643422f, -0.86968350f, -0.87289548f, -0.87607014f, -0.87920725f, -0.88230664f, -0.88536829f, -0.88839203f, -0.89137769f, -0.89432514f,
   -0.89723432f, -0.90010506f, -0.90293723f, -0.90573072f, -0.90848541f, -0.91120118f, -0.91387796f, -0.91651553f, -0.91911387f, -0.92167282f,
   -0.92419231f, -0.92667222f, -0.92911243f, -0.93151283f, -0.93387336f, -0.93619382f, -0.93847424f, -0.94071442f, -0.94291431f, -0.94507378f,
   -0.94719279f, -0.94927126f, -0.95130903f, -0.95330608f, -0.95526224f, -0.95717752f, -0.95905179f, -0.96088499f, -0.96267700f, -0.96442777f,
   -0.96613729f, -0.96780539f, -0.96943200f, -0.97101706f, -0.97256058f, -0.97406244f, -0.97552258f, -0.97694093f, -0.97831738f, -0.97965199f,
   -0.98094457f, -0.98219514f, -0.98340368f, -0.98457009f, -0.98569429f, -0.98677629f, -0.98781598f, -0.98881340f, -0.98976845f, -0.99068111f,
   -0.99155134f, -0.99237907f, -0.99316430f, -0.99390697f, -0.99460709f, -0.99526459f, -0.99587947f, -0.99645168f, -0.99698120f, -0.99746799f,
   -0.99791211f, -0.99831343f, -0.99867201f, -0.99898779f, -0.99926084f, -0.99949104f, -0.99967843f, -0.99982297f, -0.99992472f, -0.99998361f,
   0.99999869f, 0.99989158f, 0.99961317f, 0.99916345f, 0.99854255f, 0.99775058f, 0.99678761f, 0.99565387f, 0.99434954f, 0.99287480f,
   0.99122995f, 0.98941529f, 0.98743105f, 0.98527765f, 0.98295540f, 0.98046476f, 0.97780609f, 0.97497988f, 0.97198665f, 0.96882683f,
   0.96550101f, 0.96200979f, 0.95835376f, 0.95453346f, 0.95054960f, 0.94640291f, 0.94209403f, 0.93762374f, 0.93299282f, 0.92820197f,
   0.92325211f, 0.91814411f, 0.91287869f, 0.90745693f, 0.90187967f, 0.89614785f, 0.89026248f, 0.88422459f, 0.87803519f, 0.87169534f,
   0.86520612f, 0.85856867f, 0.85178405f, 0.84485358f, 0.83777827f, 0.83055943f, 0.82319832f, 0.81569612f, 0.80805415f, 0.80027372f,
   0.79235619f, 0.78430289f, 0.77611518f, 0.76779449f, 0.75934225f, 0.75075996f, 0.74204898f, 0.73321080f, 0.72424710f, 0.71515924f,
   0.70594883f, 0.69661748f, 0.68716675f, 0.67759830f, 0.66791373f, 0.65811473f, 0.64820296f, 0.63818014f, 0.62804794f, 0.61780810f,
   0.60746247f, 0.59701276f, 0.58646071f, 0.57580817f, 0.56505698f, 0.55420899f, 0.54326600f, 0.53222996f, 0.52110273f, 0.50988621f,
   0.49858227f, 0.48719296f, 0.47572014f, 0.46416581f, 0.45253196f, 0.44082057f, 0.42903364f, 0.41717321f, 0.40524128f, 0.39323992f,
   0.38117120f, 0.36903715f, 0.35683987f, 0.34458145f, 0.33226398f, 0.31988961f, 0.30746040f, 0.29497850f, 0.28244606f, 0.26986524f,
   0.25723818f, 0.24456702f, 0.23185398f, 0.21910121f, 0.20631088f, 0.19348522f, 0.18062639f, 0.16773662f, 0.15481812f, 0.14187308f,
   0.12890373f, 0.11591230f, 0.10290100f, 0.089872077f, 0.076827750f, 0.063770257f, 0.050701842f, 0.037624735f, 0.024541186f, 0.011453429f,
   -0.0016362892f, -0.014725727f, -0.027812643f, -0.040894791f, -0.053969935f, -0.067035832f, -0.080090240f, -0.093130924f, -0.10615565f, -0.11916219f,
   -0.13214831f, -0.14511178f, -0.15805040f, -0.17096193f, -0.18384418f, -0.19669491f, -0.20951195f, -0.22229309f, -0.23503613f, -0.24773891f,
   -0.26039925f, -0.27301496f, -0.28558388f, -0.29810387f, -0.31057280f, -0.32298848f, -0.33534884f, -0.34765175f, -0.35989508f, -0.37207675f,
   -0.38419467f, -0.39624676f, -0.40823093f, -0.42014518f, -0.43198743f, -0.44375566f, -0.45544785f, -0.46706200f, -0.47859612f, -0.49004826f,
   -0.50141639f, -0.51269865f, -0.52389306f, -0.53499764f, -0.54601061f, -0.55693001f, -0.56775403f, -0.57848072f, -0.58910829f, -0.59963489f,
   -0.61005878f, -0.62037814f, -0.63059121f, -0.64069623f, -0.65069145f, -0.66057515f, -0.67034572f, -0.68000144f, -0.68954057f, -0.69896162f,
   -0.70826286f, -0.71744281f, -0.72649974f, -0.73543227f, -0.74423873f, -0.75291771f, -0.76146764f, -0.76988715f, -0.77817470f, -0.78632891f,
   -0.79434842f, -0.80223179f, -0.80997771f, -0.81758487f, -0.82505190f, -0.83237761f, -0.83956063f, -0.84659988f, -0.85349399f, -0.86024189f,
   -0.86684239f, -0.87329435f, -0.87959671f, -0.88574833f, -0.89174819f, -0.89759529f, -0.90328854f, -0.90882701f, -0.91420978f, -0.91943592f,
   -0.92450452f, -0.92941469f, -0.93416560f, -0.93875647f, -0.94318646f, -0.94745487f, -0.95156091f, -0.95550388f, -0.95928317f, -0.96289814f,
   -0.96634805f, -0.96963239f, -0.97275060f, -0.97570217f, -0.97848648f, -0.98110318f, -0.98355180f, -0.98583186f, -0.98794299f, -0.98988485f,
   -0.99165714f, -0.99325943f, -0.99469161f, -0.99595332f, -0.99704438f, -0.99796462f, -0.99871385f, -0.99929196f, -0.99969882f, -0.99993443f,
   0.99999464f, 0.99956632f, 0.99845290f, 0.99665523f, 0.99417448f, 0.99101239f, 0.98717111f, 0.98265326f, 0.97746199f, 0.97160077f,
   0.96507365f, 0.95788515f, 0.95004016f, 0.94154406f, 0.93240267f, 0.92262226f, 0.91220951f, 0.90117162f, 0.88951606f, 0.87725091f,
   0.86438453f, 0.85092574f, 0.83688372f, 0.82226819f, 0.80708915f, 0.79135692f, 0.77508235f, 0.75827658f, 0.74095112f, 0.72311783f,
   0.70478898f, 0.68597710f, 0.66669506f, 0.64695615f, 0.62677377f, 0.60616189f, 0.58513457f, 0.56370622f, 0.54189157f, 0.51970547f,
   0.49716324f, 0.47428027f, 0.45107225f, 0.42755505f, 0.40374488f, 0.37965798f, 0.35531086f, 0.33072025f, 0.30590299f, 0.28087607f,
   0.25565663f, 0.23026201f, 0.20470956f, 0.17901683f, 0.15320139f, 0.12728097f, 0.10127331f, 0.075196236f, 0.049067631f, 0.022905400f,
   -0.0032725304f, -0.029448219f, -0.055603724f, -0.081721120f, -0.10778251f, -0.13377003f, -0.15966587f, -0.18545228f, -0.21111161f, -0.23662624f,
   -0.26197869f, -0.28715160f, -0.31212771f, -0.33688989f, -0.36142120f, -0.38570482f, -0.40972409f, -0.43346253f, -0.45690393f, -0.48003218f,
   -0.50283146f, -0.52528608f, -0.54738069f, -0.56910020f, -0.59042966f, -0.61135447f, -0.63186026f, -0.65193301f, -0.67155898f, -0.69072473f,
   -0.70941705f, -0.72762316f, -0.74533063f, -0.76252723f, -0.77920127f, -0.79534131f, -0.81093621f, -0.82597536f, -0.84044844f, -0.85434550f,
   -0.86765707f, -0.88037395f, -0.89248747f, -0.90398932f, -0.91487163f, -0.92512697f, -0.93474823f, -0.94372886f, -0.95206273f, -0.95974404f,
   -0.96676767f, -0.97312868f, -0.97882277f, -0.98384601f, -0.98819500f, -0.99186671f, -0.99485862f, -0.99716878f, -0.99879545f, -0.99973762f,
};
static const opus_int16 eband5ms[] = { 0,  1,  2,  3,  4,  5,  6,  7,  8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100 };
static const unsigned char band_allocation[] = {
     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    90,  80,  75,  69,  63,  56,  49,  40,  34,  29,  20,  18,  10,   0,   0,   0,   0,   0,   0,   0,   0,
   110, 100,  90,  84,  78,  71,  65,  58,  51,  45,  39,  32,  26,  20,  12,   0,   0,   0,   0,   0,   0,
   118, 110, 103,  93,  86,  80,  75,  70,  65,  59,  53,  47,  40,  31,  23,  15,   4,   0,   0,   0,   0,
   126, 119, 112, 104,  95,  89,  83,  78,  72,  66,  60,  54,  47,  39,  32,  25,  17,  12,   1,   0,   0,
   134, 127, 120, 114, 103,  97,  91,  85,  78,  72,  66,  60,  54,  47,  41,  35,  29,  23,  16,  10,   1,
   144, 137, 130, 124, 113, 107, 101,  95,  88,  82,  76,  70,  64,  57,  51,  45,  39,  33,  26,  15,   1,
   152, 145, 138, 132, 123, 117, 111, 105,  98,  92,  86,  80,  74,  67,  61,  55,  49,  43,  36,  20,   1,
   162, 155, 148, 142, 133, 127, 121, 115, 108, 102,  96,  90,  84,  77,  71,  65,  59,  53,  46,  30,   1,
   172, 165, 158, 152, 143, 137, 131, 125, 118, 112, 106, 100,  94,  87,  81,  75,  69,  63,  56,  45,  20,
   200, 200, 200, 200, 200, 200, 200, 200, 198, 193, 188, 183, 178, 173, 168, 163, 158, 153, 148, 129, 104
};


// VQ Functions ---------------------------------------------------------------

#define EPSILON 1e-15f

static inline float op_pvq_search(float *X, int *iy, int K, int N)
{
   // Get rid of the sign
   int signx[N];
   float y[N];
   for (int j = 0; j < N; ++j)
   {
      signx[j] = X[j]<0;
      X[j] = fabsf(X[j]);
      iy[j] = y[j] = 0;
   }

   float xy = 0, yy = 0;
   int pulsesLeft = K;

   // Do a pre-search by projecting on the pyramid
   float sum = 0;
   if (K > (N >> 1))
   {
      for (int j = 0; j < N; ++j)
         sum += X[j];

      // Prevents infinities and NaNs from causing too many pulses
      // to be allocated. 64 is an approximation of infinity here.
      if ((sum <= EPSILON) || (sum >= 64))
      {
         X[0] = 1.0f;
         for (int j = 1; j < N; ++j)
            X[j] = 0;
         sum = 1.0f;
      }

      // Using K+e with e < 1 guarantees we cannot get more than K pulses.
      const float rcp = (K + 0.8f) * celt_rcp(sum);
      for (int j = 0; j < N; ++j)
      {
         iy[j] = (int)floor(rcp * X[j]);
         y[j] = (float)iy[j];
         yy += (float)y[j] * (float)y[j];
         xy += (float)X[j] * (float)y[j];
         y[j] *= 2;
         pulsesLeft -= iy[j];
      }
   }

   // This should never happen, but just in case it does (e.g. on silence)
   if (pulsesLeft > (N + 3))
   {
      const float tmp = (float)pulsesLeft;
      yy += (float)tmp * (float)tmp;
      yy += (float)tmp * (float)y[0];
      iy[0] += pulsesLeft;
      pulsesLeft = 0;
   }

   for (int i = 0; i < pulsesLeft; ++i)
   {
      // Temporary sums of the new pulse(s)
      yy += 1;
      int best_id = 0;
      float Rxy = xy + X[0], Ryy = yy + y[0];

      // Approximate score: maximise Rxy/sqrt(Ryy) (Rxy guaranteed positive because sign is pre-computed)
      Rxy *= Rxy;
      float best_den = Ryy, best_num = Rxy;
      for (int j = 1; j < N; ++j)
      {
         // Temporary sums of the new pulse(s)
         Rxy = xy + X[j];
         Ryy = yy + y[j];

         // Approximate score: maximise Rxy/sqrt(Ryy)
         Rxy *= Rxy;
         if (__builtin_expect(!!((best_den * Rxy) > (Ryy * best_num)), 0))
         {
            best_den = Ryy;
            best_num = Rxy;
            best_id = j;
         }
      }

      // Updating the sums of the new pulse(s)
      xy += X[best_id];
      yy += y[best_id];

      // Now that we've made the final choice, update y/iy
      y[best_id] += 2;
      iy[best_id]++;
   }

   // Put original sign back
   for (int j = 0; j < N; ++j)
      iy[j] = (iy[j] ^ -signx[j]) + signx[j];
   return yy;
}

static void alg_quant(float *X, int N, int K, ec_ctx *enc)
{
   // Covers vectorization by up to 4
   int iy[N+3];
   op_pvq_search(X, iy, K, N);
   encode_pulses(iy, N, K, enc);
}


// Band Functions -------------------------------------------------------------

static inline int get_pulses(int i)
{
   return (i < 8) ? i : ((8 + (i & 7)) << ((i >> 3) - 1));
}

static inline int bits2pulses(int band, int bits)
{
   const unsigned char *cache = cache_bits + cache_index[84 + band];
   int lo = 0, hi = cache[0];
   bits--;
   for (int i = 0; i < 6; ++i)
   {
      const int mid = (lo + hi + 1) >> 1;
      if ((int)cache[mid] >= bits)
         hi = mid;
      else
         lo = mid;
   }
   return ((bits - (!lo ? -1 : (int)cache[lo])) <= ((int)cache[hi] - bits)) ? lo : hi;
}

static inline int pulses2bits(int band, int pulses)
{
   const unsigned char *cache = cache_bits + cache_index[84 + band];
   return !pulses ? 0 : (cache[pulses] + 1);
}

static inline void compute_band_energies(const float *X, float *bandE)
{
   const opus_int16 *eBands = eband5ms;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      float sum = 1e-27f + celt_inner_prod(&X[eBands[i] << 3], &X[eBands[i] << 3], (eBands[i + 1] - eBands[i]) << 3);
      bandE[i] = celt_sqrt(sum);
   }
}

static inline void normalise_bands(const float * restrict freq, float * restrict X, const float *bandE)
{
   const opus_int16 *eBands = eband5ms;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const float g = 1.f / (1e-27f + bandE[i]);
      for (int j = 8 * eBands[i]; j < 8 * eBands[i+1]; ++j)
         X[j] = freq[j] * g;
   }
}

static inline void quant_partition(int i, opus_int32 remaining_bits, ec_ctx *ec, float *X, int N, int b)
{
   // This is the basic no-split case
   int q = bits2pulses(i, b);
   int curr_bits = pulses2bits(i, q);
   remaining_bits -= curr_bits;

   // Ensure we can never bust the budget
   while ((remaining_bits < 0) && (q > 0))
      remaining_bits += (curr_bits - pulses2bits(i, --q));
   if (q)
      alg_quant(X, N, get_pulses(q), ec);
}

static void quant_all_bands(float *X_, int *pulses, opus_int32 total_bits, opus_int32 balance, ec_ctx *ec, int codedBands)
{
   const int M = 8;
   const opus_int16 * restrict eBands = eband5ms;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      int b;
      float *restrict X = X_ + (M * eBands[i]);
      const int N = (M * eBands[i+1]) - (M * eBands[i]);
      const opus_int32 tell = ec_tell_frac(ec);

      // Compute how many bits we want to allocate to this band
      if (i != 0)
         balance -= tell;
      const opus_int32 remaining_bits = total_bits - tell - 1;
      if (i <= (codedBands - 1))
      {
         const opus_int32 curr_balance = celt_sudiv(balance, MIN(3, codedBands - i));
         b = MAX(0, MIN(16383, MIN(remaining_bits + 1, pulses[i] + curr_balance)));
      }
      else
         b = 0;
      quant_partition(i, remaining_bits, ec, X, N, b);
      balance += pulses[i] + tell;
   }
}


// Laplace Functions ----------------------------------------------------------

static inline unsigned ec_laplace_get_freq1(unsigned fs0, int decay)
{
   return (32736 - fs0) * (opus_int32)(16384 - decay) >> 15;
}

static void ec_laplace_encode(ec_ctx *enc, int *value, unsigned fs, int decay)
{
   unsigned fl = 0;
   int val = *value;
   if (val)
   {
      const int s = -(val<0);
      val = (val + s) ^ s;
      fl = fs;
      fs = ec_laplace_get_freq1(fs, decay);

      // Search the decaying part of the PDF
      int i;
      for (i = 1; (fs > 0) && (i < val); ++i)
      {
         fs *= 2;
         fl += fs + 2;
         fs = (fs * (opus_int32)decay) >> 15;
      }

      // Everything beyond that has probability 1
      if (!fs)
      {
         int ndi_max = (32768 - fl - s) >> 1;
         const int di = MIN(val - i, ndi_max - 1);
         fl += ((2 * di) + 1 + s);
         fs = MIN(1, 32768 - fl);
         *value = (i + di + s) ^ s;
      }
      else
      {
         ++fs;
         fl += fs & ~s;
      }
   }
   ec_encode_bin(enc, fl, fl + fs);
}


// Quant Bands Functions ------------------------------------------------------

static const float eMeans[] = {
   6.437500f, 6.250000f, 5.750000f, 5.312500f, 5.062500f, 4.812500f, 4.500000f, 4.375000f, 4.875000f, 4.687500f,
   4.562500f, 4.437500f, 4.875000f, 4.625000f, 4.312500f, 4.500000f, 4.375000f, 4.625000f, 4.750000f, 4.437500f, 3.750000f, 3.750000f, 3.750000f, 3.750000f, 3.750000f
};
static const unsigned char small_energy_icdf[] = { 2, 1, 0 };
static const unsigned char e_prob_model[2][42] = {
   { 42, 121, 96, 66, 108, 43, 111, 40, 117, 44, 123, 32, 120, 36, 119, 33, 127, 33, 134, 34, 139, 21, 147, 23, 152, 20, 158, 25, 154, 26, 166, 21, 173, 16, 184, 13, 184, 10, 150, 13, 139, 15 },
   { 22, 178, 63, 114, 74, 82, 84, 83, 92, 82, 103, 62, 96, 72, 96, 67, 101, 73, 107, 72, 113, 55, 118, 52, 125, 52, 118, 52, 117, 55, 135, 49, 137, 39, 157, 32, 145, 29, 97, 33, 77, 40 }
};

static inline void amp2Log2(float *bandE, float *bandLogE)
{
   for (int i = 0; i < MAX_BANDS; ++i)
      bandLogE[i] = celt_log2(bandE[i]) - (float)eMeans[i];
}

static inline float loss_distortion(const float *eBands, float *oldEBands, int len)
{
   float dist = 0;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const float d = eBands[i] - oldEBands[i];
      dist += (float)d * (float)d;
   }
   return MIN(200, dist);
}

static int quant_coarse_energy_impl(const float *eBands, float *oldEBands, opus_int32 budget, opus_int32 tell, const unsigned char *prob_model, float *error, ec_ctx *enc, int intra, float max_decay)
{
   int badness = 0;
   float prev = 0;
   const float coef = intra ? 0 : (16384 / 32768.0f), beta = intra ? (4915 / 32768.0f) : (6554 / 32768.0f);
   if ((tell + 3) <= budget)
      ec_enc_bit_logp(enc, intra, 3);

   // Encode at a fixed coarse resolution
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const float x = eBands[i], oldE = MAX(-9.0f, oldEBands[i]);
      const float decay_bound = MAX(-28.0f, oldEBands[i]) - max_decay;
      const float f = x - (coef * oldE) - prev;
      int qi = (int)floor(0.5f + f);

      // Prevent the energy from going down too quickly (e.g. for bands that have just one bin)
      if ((qi < 0) && (x < decay_bound))
      {
         qi += (int)(decay_bound - x);
         if (qi > 0)
            qi = 0;
      }
      const int qi0 = qi;

      // If we don't have enough bits to encode all the energy, just assume something safe
      tell = ec_tell(enc);
      const int bits_left = budget - tell - (3 * (MAX_BANDS - i));
      if (i && (bits_left < 30))
      {
         if (bits_left < 24)
            qi = MIN(1, qi);
         else if (bits_left < 16)
            qi = MAX(-1, qi);
      }
      if ((budget - tell) >= 15)
      {
         const int pi = 2 * MIN(i, 20);
         ec_laplace_encode(enc, &qi, prob_model[pi] << 7, prob_model[pi + 1] << 6);
      }
      else if ((budget - tell) >= 2)
      {
         qi = MAX(-1, MIN(qi, 1));
         ec_enc_icdf(enc, 2 * qi ^ -(qi < 0), small_energy_icdf, 2);
      }
      else if ((budget -tell) >= 1)
      { 
         qi = MIN(0, qi);
         ec_enc_bit_logp(enc, -qi, 1);
      }
      else
         qi = -1;
      error[i] = f - qi;
      badness += abs(qi0 - qi);
      const float q = (float)qi;
      oldEBands[i] = ((float)coef * (float)oldE) + prev + q;
      prev += q - ((float)beta * (float)q);
   }
   return badness;
}

static void quant_coarse_energy(const float *eBands, float *oldEBands, opus_uint32 budget, float *error, ec_ctx *enc, int nbAvailableBytes, float *delayedIntra)
{
   const float new_distortion = loss_distortion(eBands, oldEBands, MAX_BANDS);
   const opus_uint32 tell = ec_tell(enc);
   const int intra = ((*delayedIntra > 42) && (nbAvailableBytes > MAX_BANDS) && ((tell + 3) <= budget));
   const float max_decay = MIN(16.f, .125f * nbAvailableBytes);
   if (intra)
   {
      float oldEBands_intra[MAX_BANDS];
      memcpy(oldEBands_intra, oldEBands, MAX_BANDS * sizeof(oldEBands[0]));
      quant_coarse_energy_impl(eBands, oldEBands_intra, budget, tell, e_prob_model[1], error, enc, 1, max_decay);
      memcpy(oldEBands, oldEBands_intra, MAX_BANDS * sizeof(oldEBands[0]));
      *delayedIntra = new_distortion;
   }
   else
   {
      quant_coarse_energy_impl(eBands, oldEBands, budget, tell, e_prob_model[0], error, enc, 0, max_decay);
      *delayedIntra = ((16384 / 32768.0f) * (16384 / 32768.0f) * *delayedIntra) + new_distortion;
   }
}

static void quant_fine_energy(float *oldEBands, float *error, int *fine_quant, ec_ctx *enc)
{
   // Encode finer resolution
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const opus_int16 frac = 1 << fine_quant[i];
      if (fine_quant[i] > 0)
      {
         int q2 = (int)floor((error[i] + .5f) * frac);
         if (q2 > (frac - 1))
            q2 = frac - 1;
         else if (q2 < 0)
            q2 = 0;
         ec_enc_bits(enc, q2, fine_quant[i]);
         const float offset = (q2 + 0.5f) * (1 << (14 - fine_quant[i])) * (1.0f / 16384) - 0.5f;
         oldEBands[i] += offset;
         error[i] -= offset;
      }
   }
}

static void quant_energy_finalise(float *oldEBands, float *error, int *fine_quant, int *fine_priority, int bits_left, ec_ctx *enc)
{
   // Use up the remaining bits
   for (int prio = 0; prio < 2; ++prio)
      for (int i = 0; (i < MAX_BANDS) && (bits_left >= 1); ++i)
         if ((fine_quant[i] < MAX_FINE_BITS) && (fine_priority[i] == prio))
         {
            const int q2 = error[i] < 0 ? 0 : 1;
            ec_enc_bits(enc, q2, 1);
            const float offset = (q2 - .5f) * (1 << (14 - fine_quant[i] - 1)) * (1.0f / 16384);
            oldEBands[i] += offset;
            error[i] -= offset;
            bits_left--;
         }
}


// Rate Functions -------------------------------------------------------------

#define ALLOC_STEPS 6

static inline int interp_bits2pulses(const int *bits1, const int *bits2, const int *thresh, const int *cap, opus_int32 total, opus_int32 *_balance, int skip_rsv, int *bits, int *ebits, int *fine_priority, ec_ctx *ec)
{
   const int alloc_floor = 1 << BITRES, logM = 3 << BITRES;
   int lo = 0, hi = 1 << ALLOC_STEPS;
   for (int i = 0; i < ALLOC_STEPS; ++i)
   {
      int done = 0, j = MAX_BANDS;
      opus_int32 psum = 0;
      const int mid = (lo + hi) >> 1;
      while (j-->0)
      {
         const int tmp = bits1[j] + (mid * (opus_int32)bits2[j] >> ALLOC_STEPS);
         if ((tmp >= thresh[j]) || done)
         {
            done = 1;
            psum += MIN(tmp, cap[j]);
         }
         else if (tmp >= alloc_floor)
            psum += alloc_floor;
      }
      if (psum > total)
         hi = mid;
      else
         lo = mid;
   }

   int done = 0, j = MAX_BANDS;
   opus_int32 psum = 0;
   while (j-->0)
   {
      int tmp = bits1[j] + ((opus_int32)lo * bits2[j] >> ALLOC_STEPS);
      if ((tmp < thresh[j]) && !done)
         tmp = (tmp >= alloc_floor) ? alloc_floor : 0;
      else
         done = 1;
      tmp = MIN(tmp, cap[j]);
      bits[j] = tmp;
      psum += tmp;
   }

   // Decide which bands to skip, working backwards from the end
   int codedBands = 22;
   while (codedBands-->0)
   {
      // Never skip the first band, nor a band that has been boosted by dynalloc
      j = codedBands - 1;
      if (j <= 0)
      {
         total += skip_rsv;
         break;
      }

      // Figure out how many left-over bits we would be adding to this band.
      // This can include bits we've stolen back from higher, skipped bands.
      opus_int32 left = total - psum;
      const opus_int32 percoeff = celt_udiv(left, eband5ms[codedBands] - eband5ms[0]);
      left -= (eband5ms[codedBands] - eband5ms[0]) * percoeff;
      const int rem = MAX(left - (eband5ms[j] - eband5ms[0]), 0), band_width = eband5ms[codedBands] - eband5ms[j];
      int band_bits = (int)(bits[j] + (percoeff * band_width) + rem);

      // Only code a skip decision if we're above the threshold for this band
      if (band_bits >= MAX(thresh[j], alloc_floor + (1 << BITRES)))
      {
         const int depth_threshold = (codedBands > 17) ? 9 : 0;
         if ((codedBands <= 2) || ((band_bits > (depth_threshold * band_width << 3 << BITRES) >> 4) && (j <= 20)))
         {
            ec_enc_bit_logp(ec, 1, 1);
            break;
         }
         ec_enc_bit_logp(ec, 0, 1);
         psum += 1 << BITRES;
         band_bits -= 1 << BITRES;
      }

      // Reclaim the bits originally allocated to this band
      psum -= bits[j];
      if (band_bits >= alloc_floor)
      {
         psum += alloc_floor;
         bits[j] = alloc_floor;
      }
      else
         bits[j] = 0;
   }

   // Allocate the remaining bits
   opus_int32 left = total - psum;
   const opus_int32 percoeff = celt_udiv(left, eband5ms[codedBands] - eband5ms[0]);
   left -= (eband5ms[codedBands] - eband5ms[0]) * percoeff;
   for (j = 0; j < codedBands; ++j)
      bits[j] += ((int)percoeff * (eband5ms[j+1] - eband5ms[j]));
   for (j = 0; j < codedBands; ++j)
   {
      int tmp = (int)MIN(left, eband5ms[j+1] - eband5ms[j]);
      bits[j] += tmp;
      left -= tmp;
   }

   opus_int32 balance = 0;
   for (j = 0; j < codedBands; ++j)
   {
      const int N0 = eband5ms[j+1] - eband5ms[j], N = N0 << 3;
      const opus_int32 bit = (opus_int32)bits[j] + balance;
      opus_int32 excess;
      if (N > 1)
      {
         // Compensate for the extra DoF in stereo
         excess = MAX(bit - cap[j], 0);
         bits[j] = bit - excess;
         const int NClogN = N * (logN400[j] + logM);

         // Offset for the number of fine bits by log2(N)/2 + FINE_OFFSET compared to their "fair share" of total/N
         int offset = (NClogN >> 1) - (N * FINE_OFFSET);
         if (N == 2)
            offset += N << BITRES >> 2;
         if (bits[j] + offset < N * 2 << BITRES)
            offset += NClogN >> 2;
         else if (bits[j] + offset < N * 3 << BITRES)
            offset += NClogN >> 3;
         ebits[j] = MAX(0, (bits[j] + offset + (N << (BITRES - 1))));
         ebits[j] = celt_udiv(ebits[j], N) >> BITRES;
         if (ebits[j] > (bits[j] >> BITRES))
            ebits[j] = bits[j] >> BITRES;
         ebits[j] = MIN(ebits[j], MAX_FINE_BITS);

         // If rounded down or capped this band, make it a candidate for the final fine energy pass
         fine_priority[j] = ebits[j] * (N << BITRES) >= (bits[j] + offset);
         bits[j] -= ebits[j] << BITRES;
      }
      else  // For N=1, all bits go to fine energy except for a single sign bit
      {
         excess = MAX(0, bit - (1 << BITRES));
         bits[j] = bit - excess;
         ebits[j] = 0;
         fine_priority[j] = 1;
      }

      if (excess > 0)
      {
         const int extra_fine = MIN(excess >> (BITRES), MAX_FINE_BITS - ebits[j]);
         ebits[j] += extra_fine;
         const int extra_bits = extra_fine * 1 << BITRES;
         fine_priority[j] = extra_bits >= excess - balance;
         excess -= extra_bits;
      }
      balance = excess;
   }
   *_balance = balance;

   // The skipped bands use all their bits for fine energy
   for (; j < MAX_BANDS; ++j)
   {
      ebits[j] = bits[j] >> BITRES;
      bits[j] = 0;
      fine_priority[j] = ebits[j] < 1;
   }
   return codedBands;
}

static int clt_compute_allocation(const int *cap, int alloc_trim, opus_int32 total, opus_int32 *balance, int *pulses, int *ebits, int *fine_priority, ec_ctx *ec)
{
   // Reserve a bit to signal the end of manually skipped bands
   total = MAX(total, 0);
   const int skip_rsv = (total >= 1 << BITRES) ? 1 << BITRES : 0;
   int bits1[MAX_BANDS], bits2[MAX_BANDS], thresh[MAX_BANDS], trim_offset[MAX_BANDS];
   total -= skip_rsv;

   for (int j = 0; j < MAX_BANDS; ++j)
   {
      thresh[j] = MAX(1 << BITRES, (3 * (eband5ms[j+1] - eband5ms[j]) << 3 << BITRES) >> 4);
      trim_offset[j] = (eband5ms[j+1] - eband5ms[j]) * (alloc_trim - 8) * (20 - j) * (1 << (3 + BITRES)) >> 6;
      if ((eband5ms[j+1] - eband5ms[j]) << 3 == 1)
         trim_offset[j] -= 1 << BITRES;
   }
   int lo = 1, hi = 10;
   do
   {
      int done = 0, j = MAX_BANDS, psum = 0;
      int const mid = (lo + hi) >> 1;
      while (j-->0)
      {
         const int N = eband5ms[j+1] - eband5ms[j];
         int bitsj = N * band_allocation[(mid * MAX_BANDS) + j] << 3 >> 2;
         if (bitsj > 0)
            bitsj = MAX(0, bitsj + trim_offset[j]);
         if ((bitsj >= thresh[j]) || done)
         {
            done = 1;
            psum += MIN(bitsj, cap[j]);
         }
         else if (bitsj >= (1 << BITRES))
            psum += 1 << BITRES;
      }
      if (psum > total)
         hi = mid - 1;
      else
         lo = mid + 1;
   } while (lo <= hi);
   hi = lo--;

   for (int j = 0; j < MAX_BANDS; ++j)
   {
      const int N = eband5ms[j+1] - eband5ms[j];
      const int bits1j = N * band_allocation[(lo * MAX_BANDS) + j] << 3 >> 2, bits2j = (hi >= 11) ? cap[j] : (N * band_allocation[(hi * MAX_BANDS) + j] << 3 >> 2);
      bits1[j] = (bits1j > 0) ? MAX(0, bits1j + trim_offset[j]) : bits1j;
      bits2[j] = MAX(0, ((bits2j > 0) ? MAX(0, bits2j + trim_offset[j]) : bits2j) - bits1[j]);
   }
   return interp_bits2pulses(bits1, bits2, thresh, cap, total, balance, skip_rsv, pulses, ebits, fine_priority, ec);
}


// FFT Functions --------------------------------------------------------------

#define C_MUL(m, a, b) (m).r = (a).r*(b).r - (a).i*(b).i; (m).i = (a).r*(b).i + (a).i*(b).r
#define C_ADD(res, a, b) (res).r = (a).r + (b).r; (res).i = (a).i + (b).i
#define C_SUB(res, a, b) (res).r = (a).r - (b).r; (res).i = (a).i - (b).i
#define C_ADDTO(res, a) (res).r += (a).r; (res).i += (a).i

static void kf_bfly2(fft_cpx *Fout)
{
   for (int i = 0; i < 60; ++i)
   {
      fft_cpx *Fout2 = Fout + 4;
      fft_cpx t = Fout2[0];
      C_SUB(Fout2[0], Fout[0], t);
      C_ADDTO(Fout[0], t);
      t.r = (Fout2[1].r + Fout2[1].i) * 0.7071067812f;
      t.i = (Fout2[1].i - Fout2[1].r) * 0.7071067812f;
      C_SUB(Fout2[1], Fout[1], t);
      C_ADDTO(Fout[1], t);
      t.r = Fout2[2].i;
      t.i = -Fout2[2].r;
      C_SUB(Fout2[2], Fout[2], t);
      C_ADDTO(Fout[2], t);
      t.r = (Fout2[3].i - Fout2[3].r) * 0.7071067812f;
      t.i = -(Fout2[3].i + Fout2[3].r) * 0.7071067812f;
      C_SUB(Fout2[3], Fout[3], t);
      C_ADDTO(Fout[3], t);
      Fout += 8;
   }
}

static void kf_bfly4_m1(fft_cpx *Fout)
{
   for (int i = 0; i < 120; ++i)
   {
      fft_cpx scratch0, scratch1;
      C_SUB(scratch0, *Fout, Fout[2]);
      C_ADDTO(*Fout, Fout[2]);
      C_ADD(scratch1, Fout[1], Fout[3]);
      C_SUB(Fout[2], *Fout, scratch1);
      C_ADDTO(*Fout, scratch1);
      C_SUB(scratch1, Fout[1], Fout[3]);
      Fout[1].r = scratch0.r + scratch1.i;
      Fout[1].i = scratch0.i - scratch1.r;
      Fout[3].r = scratch0.r - scratch1.i;
      Fout[3].i = scratch0.i + scratch1.r;
      Fout += 4;
   }
}

static void kf_bfly4_m8(fft_cpx *Fout)
{
   fft_cpx scratch[6];
   const twiddle_cpx *tw1, *tw2, *tw3;
   fft_cpx *Fout_beg = Fout;
   for (int i = 0; i < 15; ++i)
   {
      Fout = Fout_beg + (32 * i);
      tw3 = tw2 = tw1 = fft_twiddles;
      for (int j = 0; j < 8; ++j)
      {
         C_MUL(scratch[0],Fout[8], *tw1);
         C_MUL(scratch[1],Fout[16], *tw2);
         C_MUL(scratch[2],Fout[24], *tw3);
         C_SUB(scratch[5], *Fout, scratch[1]);
         C_ADDTO(*Fout, scratch[1]);
         C_ADD(scratch[3], scratch[0], scratch[2]);
         C_SUB(scratch[4], scratch[0], scratch[2]);
         C_SUB(Fout[16], *Fout, scratch[3]);
         tw1 += 15; tw2 += 30; tw3 += 45;
         C_ADDTO(*Fout, scratch[3]);
         Fout[8].r = scratch[5].r + scratch[4].i;
         Fout[8].i = scratch[5].i - scratch[4].r;
         Fout[24].r = scratch[5].r - scratch[4].i;
         Fout[24].i = scratch[5].i + scratch[4].r;
         ++Fout;
      }
   }
}

static void kf_bfly3(fft_cpx *Fout)
{
   fft_cpx scratch[5], *Fout_beg = Fout;
   const twiddle_cpx epi3 = fft_twiddles[160];
   for (int i = 0; i < 5; ++i)
   {
      Fout = Fout_beg + (96 * i);
      const twiddle_cpx *tw1 = fft_twiddles, *tw2 = fft_twiddles;
      for (int k = 0; k < 32; ++k)
      {
         C_MUL(scratch[1], Fout[32], *tw1);
         C_MUL(scratch[2], Fout[64], *tw2);
         C_ADD(scratch[3], scratch[1], scratch[2]);
         C_SUB(scratch[0], scratch[1], scratch[2]);
         tw1 += 5; tw2 += 10;
         Fout[32].r = Fout->r - (0.5f * scratch[3].r);
         Fout[32].i = Fout->i - (0.5f * scratch[3].i);
         scratch[0].r *= epi3.i;
         scratch[0].i *= epi3.i;
         C_ADDTO(*Fout, scratch[3]);
         Fout[64].r = Fout[32].r + scratch[0].i;
         Fout[64].i = Fout[32].i - scratch[0].r;
         Fout[32].r = Fout[32].r - scratch[0].i;
         Fout[32].i = Fout[32].i + scratch[0].r;
         ++Fout;
      }
   }
}

static void kf_bfly5(fft_cpx *Fout)
{
   fft_cpx scratch[13];
   twiddle_cpx ya = fft_twiddles[96], yb = fft_twiddles[192];
   const twiddle_cpx *tw = fft_twiddles;
   fft_cpx *Fout0 = Fout, *Fout1 = Fout0 + 96, *Fout2 = Fout0 + 192;
   fft_cpx *Fout3 = Fout0 + 288, *Fout4 = Fout0 + 384;
   for (int u = 0; u < 96; ++u)
   {
      scratch[0] = *Fout0;
      C_MUL(scratch[1] ,*Fout1, tw[u]);
      C_MUL(scratch[2] ,*Fout2, tw[2*u]);
      C_MUL(scratch[3] ,*Fout3, tw[3*u]);
      C_MUL(scratch[4] ,*Fout4, tw[4*u]);
      C_ADD(scratch[7], scratch[1], scratch[4]);
      C_SUB(scratch[10], scratch[1], scratch[4]);
      C_ADD(scratch[8], scratch[2], scratch[3]);
      C_SUB(scratch[9], scratch[2], scratch[3]);
      Fout0->r = Fout0->r + scratch[7].r + scratch[8].r;
      Fout0->i = Fout0->i + scratch[7].i + scratch[8].i;
      scratch[5].r = scratch[0].r + (scratch[7].r * ya.r) + (scratch[8].r * yb.r);
      scratch[5].i = scratch[0].i + (scratch[7].i * ya.r) + (scratch[8].i * yb.r);
      scratch[6].r =  (scratch[10].i * ya.i) + (scratch[9].i * yb.i);
      scratch[6].i = -((scratch[10].r * ya.i) + (scratch[9].r * yb.i));
      C_SUB(*Fout1,scratch[5],scratch[6]);
      C_ADD(*Fout4,scratch[5],scratch[6]);
      scratch[11].r = scratch[0].r + (scratch[7].r * yb.r) + (scratch[8].r * ya.r);
      scratch[11].i = scratch[0].i + (scratch[7].i * yb.r) + (scratch[8].i * ya.r);
      scratch[12].r = (scratch[9].i * ya.i) - (scratch[10].i * yb.i);
      scratch[12].i = (scratch[10].r * yb.i) - (scratch[9].r * ya.i);
      C_ADD(*Fout2, scratch[11], scratch[12]);
      C_SUB(*Fout3, scratch[11], scratch[12]);
      ++Fout0; ++Fout1; ++Fout2; ++Fout3; ++Fout4;
   }
}

static inline void opus_fft_impl(fft_cpx *fout)
{
   kf_bfly4_m1(fout);
   kf_bfly2(fout);
   kf_bfly4_m8(fout);
   kf_bfly3(fout);
   kf_bfly5(fout);
}


// MDCT Functions -------------------------------------------------------------

static void compute_mdcts(float *in, float *restrict out)
{
   static float f[960];
   static fft_cpx f2[480];

   // Consider the input to be composed of four blocks: [a, b, c, d]
   // Window, shuffle, fold
   {
      int i;
      float *restrict yp = f;
      const float *restrict xp1 = in + 60, *restrict xp2 = in + 1019;
      const float *restrict wp1 = window120 + 60, *restrict wp2 = window120 + 59;
      for(i = 0; i < 30; ++i)
      {
         // Real part arranged as -d-cR, Imag part arranged as -b+aR
         *yp++ = (*wp2 * xp1[960]) + (*wp1 * *xp2);
         *yp++ = (*wp1 * *xp1) - (*wp2 * xp2[-960]);
         xp1 += 2; xp2 -= 2; wp1 += 2; wp2 -= 2;
      }
      wp1 = window120;
      wp2 = window120 + 119;
      for(; i < 450; ++i)
      {
         // Real part arranged as a-bR, Imag part arranged as -c-dR
         *yp++ = *xp2; *yp++ = *xp1;
         xp1 += 2; xp2 -= 2;
      }
      for(; i < 480; ++i)
      {
         // Real part arranged as a-bR, Imag part arranged as -c-dR
         *yp++ = -(*wp1 * xp1[-960]) + (*wp2 * *xp2);
         *yp++ = (*wp2 * *xp1) +(*wp1 * xp2[960]);
         xp1 += 2; xp2 -= 2; wp1 += 2; wp2 -= 2;
      }
   }

   // Pre-rotate
   {
      float *restrict yp = f;
      for(int i = 0; i < 480; ++i)
      {
         const float t0 = mdct_twiddles[i], t1 = mdct_twiddles[480 + i];
         const float re = *yp++, im = *yp++;
         const float yr = (re * t0) - (im * t1), yi = (im * t0) + (re * t1);
         const fft_cpx yc = { .r = 0.002083333f * yr, .i = 0.002083333f * yi };
         f2[fft_bitrev[i]] = yc;
      }
   }

   // N/4 complex FFT
   opus_fft_impl(f2);

   // Post-rotate
   {
      const fft_cpx *restrict fp = f2;
      float *restrict yp1 = out, *restrict yp2 = out + 959;
      for (int i = 0; i < 480; ++i)
      {
         *yp1 = (fp->i * mdct_twiddles[480 + i]) - (fp->r * mdct_twiddles[i]);
         *yp2 = (fp->r * mdct_twiddles[480 + i]) + (fp->i * mdct_twiddles[i]);
         yp1 += 2; yp2 -= 2;
         fp++;
      }
   }
}


// CELT Encoder Functions -----------------------------------------------------

static const unsigned char trim_icdf[11] = { 126, 124, 119, 109, 87, 41, 19, 9, 4, 2, 0 };
static const unsigned char spread_icdf[4] = { 25, 23, 2, 0 };

// Static buffers to avoid stack allocation overhead
static float bandE[MAX_BANDS], X[MAX_FRAME_SIZE];
static float in[MAX_FRAME_SIZE + MAX_OVERLAP], freq[MAX_FRAME_SIZE];
static float bandLogE[MAX_BANDS], error[MAX_BANDS];
static int cap[MAX_BANDS], fine_quant[MAX_BANDS];
static int pulses[MAX_BANDS], fine_priority[MAX_BANDS];

static inline void init_caps(int *cap)
{
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const int N = (eband5ms[i+1] - eband5ms[i]) << 3;
      cap[i] = (cache_caps[126 + i] + 64) * N >> 2;
   }
}

static inline void celt_preemphasis(const float *restrict pcmp, float *restrict inp, float *mem)
{
   float m = *mem;
   for (int i = 0; i < 960; ++i)
   {
      const float x = pcmp[i];
      inp[i] = x - m;
      m = 0.85000610f * (float)x;
   }
   *mem = m;
}

static inline void tf_encode(ec_ctx *enc)
{
   // Reserve space to code the tf_select decision
   opus_uint32 budget = enc->storage * 8, tell = ec_tell(enc);
   budget -= ((tell + 5) <= budget);

   // Apply time-frequency resolution changes
   for (int i = 0, logp = 4; i < MAX_BANDS; ++i)
   {
      if ((tell + logp) <= budget)
      {
         ec_enc_bit_logp(enc, 0, logp);
         tell = ec_tell(enc);
      }
      logp = 5;
   }
}

static inline int alloc_trim_analysis(const float *bandLogE)
{
   // Estimate spectral tilt
   float diff = 0;
   for (int i = 0; i < 20; ++i)
      diff += bandLogE[i] * (opus_int32)(2 + (2*i) - MAX_BANDS);
   diff /= 20;
   const float trim = 4.0f - MAX(-2.0f, MIN(2.0f, (diff + 1.0f) / 6));
   return MAX(0, MIN(10, (int)floor(0.5f + trim)));
}

static inline float dynalloc_analysis(const float *bandLogE, const opus_int16 *logN)
{
   float maxDepth = -31.9f;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      const float noise_floor = ((float)0.0625f * (float)logN[i]) + 9.5f - 16 - eMeans[i] + ((float)0.0062f * (float)((i+5)*(i+5)));
      maxDepth = MAX(maxDepth, bandLogE[i] - noise_floor);
   }
   return maxDepth;
}

static inline void run_prefilter(opus_encoder_t *encoder, float *in, float *prefilter_mem)
{
   memcpy(in, encoder->in_mem, MAX_OVERLAP * sizeof(in[0]));
   memcpy(encoder->in_mem, in + 960, MAX_OVERLAP * sizeof(encoder->in_mem[0]));
   memmove(prefilter_mem, prefilter_mem + 960, (COMBFILTER_MAXPERIOD - 960) * sizeof(prefilter_mem[0]));
   memcpy(prefilter_mem + COMBFILTER_MAXPERIOD - 960, in + MAX_OVERLAP, 960 * sizeof(prefilter_mem[0]));
}

static inline int compute_vbr(opus_int32 base_target, opus_int32 bitrate, float maxDepth, float temporal_vbr)
{
   // Apply transient boost, compensating for average boost
   opus_int32 target = base_target - (19 << 3);
   target += (opus_int32)(-0.044f * target);
   const int bins = eband5ms[19] << 3;
   const opus_int32 floor_depth = MAX((opus_int32)((float)(bins << BITRES) * (float)maxDepth), target >> 2);
   target = MIN(target, floor_depth);
   const float amount = 0.0000031f * MAX(0, MIN(32000, 96000 - bitrate));
   const float tvbr_factor = (float)temporal_vbr * (float)amount;
   target += (opus_int32)(tvbr_factor * target);
   return MIN(2 * base_target, target);
}

static inline int celt_encode_with_ec(opus_encoder_t *restrict encoder, const float *restrict pcm, int nbCompressedBytes, ec_ctx *enc)
{
   const opus_int32 equiv_rate = MIN((opus_int32)nbCompressedBytes * 400, encoder->bitrate);
   opus_int32 total_bits = nbCompressedBytes * 8;

   ec_enc_bit_logp(enc, 0, 15);
   celt_preemphasis(pcm, in + MAX_OVERLAP, &encoder->preemph_mem);
   run_prefilter(encoder, in, encoder->in_mem + MAX_OVERLAP);
   ec_enc_bit_logp(enc, 0, 1);
   compute_mdcts(in, freq);
   compute_band_energies(freq, bandE);
   amp2Log2(bandE, bandLogE);

   // Temporal VBR
   float frame_avg = 0, follow = -10.0f;
   for (int i = 0; i < MAX_BANDS; ++i)
   {
      follow = MAX(follow - 1.0f, bandLogE[i]);
      frame_avg += follow;
   }
   frame_avg /= MAX_BANDS;
   const float temporal_vbr = MAX(-1.5f, MIN(3.0f, frame_avg - encoder->spec_avg));
   encoder->spec_avg += 0.02f * temporal_vbr;
   ec_enc_bit_logp(enc, 0, 3);

   // Band normalisation
   normalise_bands(freq, X, bandE);
   const float maxDepth = dynalloc_analysis(bandLogE, logN400);
   for (int i = 0; i < MAX_BANDS; ++i)
      if (fabsf(bandLogE[i] - encoder->oldBandE[i]) < 2.0f)
         bandLogE[i] -= encoder->energyError[i] * 0.25f;
   quant_coarse_energy(bandLogE, encoder->oldBandE, total_bits, error, enc, nbCompressedBytes, &encoder->delayedIntra);
   tf_encode(enc);
   ec_enc_icdf(enc, 0, spread_icdf, 5);

   init_caps(cap);
   total_bits <<= BITRES;
   for (int i = 0; i < MAX_BANDS; ++i)
      ec_enc_bit_logp(enc, 0, 6);
   const int alloc_trim = alloc_trim_analysis(bandLogE);
   ec_enc_icdf(enc, alloc_trim, trim_icdf, 7);

   // The target rate in 8th bits per frame
   const opus_int32 tell = ec_tell_frac(enc);
   const opus_int32 target = compute_vbr(encoder->target_vbr, equiv_rate, maxDepth, temporal_vbr) + tell;
   const opus_int32 min_allowed = ((tell + (1 << (BITRES + 3)) - 1) >> (BITRES + 3)) + 2;
   const int nbAvailableBytes = MAX(min_allowed, (target + (1 << (BITRES + 2))) >> (BITRES + 3));
   nbCompressedBytes = MIN(nbCompressedBytes, nbAvailableBytes);
   ec_enc_shrink(enc, nbCompressedBytes);

   // Bit allocation
   opus_int32 balance;
   const opus_int32 bits = (((opus_int32)nbCompressedBytes * 8) << BITRES) - ec_tell_frac(enc) - 1;
   const int codedBands = clt_compute_allocation(cap, alloc_trim, bits, &balance, pulses, fine_quant, fine_priority, enc);
   quant_fine_energy(encoder->oldBandE, error, fine_quant, enc);
   quant_all_bands(X, pulses, nbCompressedBytes * (8 << BITRES), balance, enc, codedBands);
   quant_energy_finalise(encoder->oldBandE, error, fine_quant, fine_priority, (nbCompressedBytes * 8) - ec_tell(enc), enc);
   memset(encoder->energyError, 0, MAX_BANDS * sizeof(encoder->energyError[0]));
   for (int i = 0; i < MAX_BANDS; ++i)
      encoder->energyError[i] = MAX(-0.5f, MIN(0.5f, error[i]));
   memcpy(encoder->oldLogE2, encoder->oldLogE, MAX_BANDS * sizeof(encoder->oldLogE2[0]));
   memcpy(encoder->oldLogE, encoder->oldBandE, MAX_BANDS * sizeof(encoder->oldLogE[0]));
   ec_enc_done(enc);
   return nbCompressedBytes;
}


// Opus Encoder Functions -----------------------------------------------------

void opus_encoder_create(opus_encoder_t *encoder, int32_t bitrate_bps, int32_t frame_size)
{
   // Clear the Opus encoder struct
   memset(encoder, 0, sizeof(opus_encoder_t));

   // Create and initialize the CELT encoder
   encoder->bitrate = bitrate_bps;
   encoder->target_vbr = (((bitrate_bps * frame_size) + 3000) / 6000) - (60 << BITRES);
   for (int i = 0; i < MAX_BANDS; ++i)
      encoder->oldLogE[i] = encoder->oldLogE2[i] = -28.0f;
   encoder->delayedIntra = 1;

   // Generate the TOC byte
   encoder->toc = 0x80;
   int period = 0, framerate = 48000 / frame_size;
   while (framerate < 400)
   {
      framerate <<= 1;
      period++;
   }
   const int bandwidth = 3;
   encoder->toc |= bandwidth << 5;
   encoder->toc |= period << 3;
}

int32_t opus_encode(opus_encoder_t *encoder, const float *restrict pcm, unsigned char *data, uint32_t out_data_bytes)
{
   ec_ctx enc;
   data[0] = encoder->toc;
   ec_enc_init(&enc, data + 1, out_data_bytes - 1);
   return 1 + celt_encode_with_ec(encoder, pcm, out_data_bytes - 1, &enc);
}
